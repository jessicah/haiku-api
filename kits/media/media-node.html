
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>BMediaNode &#8212; The Haiku Book  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/code.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="BMediaRoster" href="media-roster.html" />
    <link rel="prev" title="BMediaFormats" href="media-formats.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>API Documentation</span></a></h1>
        <h2 class="heading"><span>BMediaNode</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="media-formats.html">BMediaFormats</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="media-roster.html">BMediaRoster</a>&#160;&#160;»
        </p>

      </div>
        
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">BMediaNode</a><ul>
<li><a class="reference internal" href="#constructor-and-destructor">Constructor and Destructor</a><ul>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode10BMediaNodeEPKc">BMediaNode</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNodeD0Ev">~BMediaNode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#member-functions">Member Functions</a><ul>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode7AcquireEv">Acquire</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode7ReleaseEv">Release</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode11AddNodeKindE6uint64">AddNodeKind</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode5AddOnEP5int32">AddOn</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode8AddTimerE9bigtime_t5int32">AddTimer</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode12TimerExpiredE9bigtime_t5int328status_t">TimerExpired</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode11ControlPortEv">ControlPort</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode10DeleteHookEP10BMediaNode">DeleteHook</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode17GetNodeAttributesEP20media_node_attribute6size_t">GetNodeAttributes</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode16HandleBadMessageE5int32PKv6size_t">HandleBadMessage</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t">HandleMessage</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode2IDEv">ID</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode5KindsEv">Kinds</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode4NameEv">Name</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode12NewChangeTagEv">NewChangeTag</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode4NodeEv">Node</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode14NodeRegisteredEv">NodeRegistered</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode11NodeStoppedE9bigtime_t">NodeStopped</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode7PrerollEv">Preroll</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode11ReportErrorE10node_errorPK8BMessage">ReportError</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode16RequestCompletedERK18media_request_info">RequestCompleted</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode7RunModeEv">RunMode</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode4SeekE9bigtime_t9bigtime_t">Seek</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode13SetTimeSourceEP11BTimeSource">SetTimeSource</a></li>
<li><a class="reference internal" href="#_CPPv4NK10BMediaNode10TimeSourceEv">TimeSource</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode5StartE9bigtime_t">Start</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode4StopE9bigtime_tb">Stop</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode8TimeWarpE9bigtime_t9bigtime_t">TimeWarp</a></li>
<li><a class="reference internal" href="#_CPPv4N10BMediaNode14WaitForMessageE9bigtime_t6uint32Pv">WaitForMessage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constants">Constants</a><ul>
<li><a class="reference internal" href="#node-error">node_error</a></li>
<li><a class="reference internal" href="#run-mode">run_mode</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>

        </div>
      </div>
          <div class="bodywrapper">
      <div class="content" role="main">
        
  <section id="bmedianode">
<h1 id="CPPv410BMediaNode">BMediaNode<a class="headerlink" href="#bmedianode" title="Permalink to this heading">¶</a></h1>
<section id="constructor-and-destructor">
<h2>Constructor and Destructor<a class="headerlink" href="#constructor-and-destructor" title="Permalink to this heading">¶</a></h2>
<section id="_CPPv4N10BMediaNode10BMediaNodeEPKc">
</section>
<h3>
BMediaNode()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">explicit</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv4N10BMediaNode10BMediaNodeEPKc" title="BMediaNode::BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">BMediaNode</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">name</span><span class="sig-paren">)</span></pre><p>Call this from your derived node’s constructor.</p>
<p>The node is created with a reference count of 1; the count is incremented
each time the <a class="reference internal" href="#_CPPv4N10BMediaNode7AcquireEv" title="BMediaNode::Acquire"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Acquire()</span></code></a> call is issued,
and decremented each time <a class="reference internal" href="#_CPPv4N10BMediaNode7ReleaseEv" title="BMediaNode::Release"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Release()</span></code></a> is
called. When the reference count becomes zero, the node is deleted.</p>
<section id="_CPPv4N10BMediaNodeD0Ev">
</section>
<h3>
~BMediaNode()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">~BMediaNode</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>You may never delete a <span class="hclass">BMediaNode</span> because you don’t know for
certain when the Media Server is done with it. Instead, the Media Server
maintains a reference count for the node, and when it is no longer in use,
the node will be deleted automatically.</p>
</section>
<section id="member-functions">
<h2>Member Functions<a class="headerlink" href="#member-functions" title="Permalink to this heading">¶</a></h2>
<section id="_CPPv4N10BMediaNode7AcquireEv">
</section>
<section id="_CPPv4N10BMediaNode7ReleaseEv">
</section>
<h3>
Acquire(), Release()</h3><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="w"> </span><span class="p">*</span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Acquire</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="w"> </span><span class="p">*</span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Release</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p><span class="hmethod">Acquire()</span> returns a pointer to the node, after incrementing the
node’s reference count.</p>
<p><span class="hmethod">Release()</span> releases the node by decrementing its reference
count. If the count reaches zero, the node is deleted and <span class="cpp-expr sig sig-inline cpp"><span class="n">NULL</span></span>
is returned; otherwise, a pointer to the node is returned.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>Although you usually can’t call node member functions directly from within
an application, you can call <span class="hmethod">Acquire()</span> and <span class="hmethod">Release()</span>
directly if the node is subclassed within the application itself (rather
than in an add-on).</p>
</div>
<section id="_CPPv4N10BMediaNode11AddNodeKindE6uint64">
</section>
<h3>
AddNodeKind()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">AddNodeKind</span><span class="sig-paren">(</span><span class="n">uint64</span><span class="w"> </span><span class="n sig-param">kind</span><span class="sig-paren">)</span></pre><p>Adds a kind to the set of kinds supported by the node. This lets the
system know what types of node interfaces are supported by the node’s
implementation. Possible values include <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_BUFFER_PRODUCER</span></code>
(which indicates that the node implements the <a class="reference internal" href="buffer-producer.html#_CPPv415BBufferProducer" title="BBufferProducer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferProducer</span></code></a>
protocol) and <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_PHYSICAL_INPUT</span></code> (which indicates that the
node implements a physical input, such as a sound digitizing input device).
For a complete list of kind values, see <span class="xref std std-ref">node_kind</span>.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>In general, you don’t need to call this function. The base system classes
call <span class="hmethod">AddNodeKind()</span> automatically to set up the node type flags;
for example, a <a class="reference internal" href="buffer-producer.html#_CPPv415BBufferProducer" title="BBufferProducer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferProducer</span></code></a> automatically calls
<code class="docutils literal notranslate"><span class="pre">AddNodeKind(B_BUFFER_PRODUCER)</span></code>. The only time it’s necessary go call
<span class="hmethod">AddNodeKind()</span> is if the node you’re implementing is a physical
device or a mixer, in which case you need to add the
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_PHYSICAL_INPUT</span></code>, <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_PHYSICAL_OUTPUT</span></code>, or
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SYSTEM_MIXER</span></code> flag.</p>
</div>
<section id="_CPPv4NK10BMediaNode5AddOnEP5int32">
</section>
<h3>
AddOn()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><a class="reference internal" href="media-add-on.html#_CPPv411BMediaAddOn" title="BMediaAddOn"><span class="n">BMediaAddOn</span></a><span class="w"> </span><span class="p">*</span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">AddOn</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">outInternalID</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></pre><p>Implement this function to return a pointer to the
<a class="reference internal" href="media-add-on.html#_CPPv411BMediaAddOn" title="BMediaAddOn"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BMediaAddOn</span></code></a> that instantiated the node. If the node lives in
an application (rather than in an add-on), return <span class="cpp-expr sig sig-inline cpp"><span class="n">NULL</span></span>. If the
node is in an add-on, <span class="hparameter">outInternalID</span> should be changed to contain
the internal ID number of the node within the add-on.</p>
<section id="_CPPv4N10BMediaNode8AddTimerE9bigtime_t5int32">
</section>
<section id="_CPPv4N10BMediaNode12TimerExpiredE9bigtime_t5int328status_t">
</section>
<h3>
AddTimer(), TimerExpired()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">AddTimer</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">toPerformanceTime</span>, <span class="n">int32</span><span class="w"> </span><span class="n sig-param">cookie</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">TimerExpired</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">notifyPoint</span>, <span class="n">int32</span><span class="w"> </span><span class="n sig-param">cookie</span>, <a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n sig-param">error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">B_OK</span><span class="sig-paren">)</span></pre><p>Your node should implement the <span class="hmethod">AddTimer()</span> function to remember
the <span class="hparameter">cookie</span> and time given. When the time
<span class="hparameter">toPerformanceTime</span> is reached, your node should call
<span class="hmethod">TimerExpired()</span> with the corresponding <span class="hparameter">cookie</span> value,
passing the recorded <span class="hparameter">toPerformanceTime</span> value as the
<span class="hparameter">notifyPoint</span> argument. This will, in turn, cause the
<a class="reference internal" href="media-roster.html#_CPPv4N12BMediaRoster10SyncToNodeEK10media_node9bigtime_t9bigtime_t" title="BMediaRoster::SyncToNode"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BMediaRoster::SyncToNode()</span></code></a> call that instigated the timer to
return to the caller.</p>
<p>Your implementation of <span class="hmethod">AddTimer()</span> should return
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code> if all is well; otherwise it should return an
appropriate error code.</p>
<section id="_CPPv4NK10BMediaNode11ControlPortEv">
</section>
<h3>
ControlPort()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">port_id</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">ControlPort</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span></pre><p>Returns the {htype}``port_id of the port to which the node listens for
requests. Your node must implement this to return a valid Kernel Kit port.</p>
<section id="_CPPv4N10BMediaNode10DeleteHookEP10BMediaNode">
</section>
<h3>
DeleteHook()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">DeleteHook</span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="w"> </span><span class="p">*</span><span class="n sig-param">node</span><span class="sig-paren">)</span></pre><p>The <span class="hmethod">DeleteHook()</span> function is called to delete the
<span class="hclass">BMediaNode</span> object. You may augment this if you need to perform
additional work before the node is deleted, but you should always either
include the line:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">delete</span><span class="w"> </span><span class="k">this</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>or you should call through to the inherited form of the function. Return
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code> if the node was deleted successfully, otherwise
return an appropriate error code.</p>
<section id="_CPPv4N10BMediaNode17GetNodeAttributesEP20media_node_attribute6size_t">
</section>
<h3>
GetNodeAttributes()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">GetNodeAttributes</span><span class="sig-paren">(</span><span class="n">media_node_attribute</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">outAttributes</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">inMaxCount</span><span class="sig-paren">)</span></pre><p>Implement this function to fill the <span class="hparameter">outAttributes</span> array (which
has room for <span class="hparameter">inMaxCount</span> attributes) with your node’s attributes.</p>
<p>Return <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code> if all is well, or return an appropriate
error code.</p>
<section id="_CPPv4N10BMediaNode16HandleBadMessageE5int32PKv6size_t">
</section>
<h3>
HandleBadMessage()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">HandleBadMessage</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="n sig-param">message</span>, <span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">data</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span><span class="sig-paren">)</span></pre><p>If your node receives a message that neither the node, nor any interface
from which the node is derived, understands the message, pass the message
along to this function, which will work magic to deal with the problem one
way or another. All arguments received by the <a class="reference internal" href="#_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t" title="BMediaNode::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HandleMessage()</span></code></a> function should be passed directly through to
<span class="hmethod">HandleBadMessage()</span>.</p>
<section id="_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t">
</section>
<h3>
HandleMessage()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">HandleMessage</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="n sig-param">message</span>, <span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">data</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span><span class="sig-paren">)</span></pre><p>Given a message received on the control port, this function dispatches the
message to the appropriate <span class="hclass">BMediaNode</span> hook function. If the
message doesn’t correspond to a hook function, <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_ERROR</span></code> is
returned.</p>
<p>When you implement a media node of your own (derived from
<a class="reference internal" href="buffer-consumer.html#_CPPv415BBufferConsumer" title="BBufferConsumer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferConsumer</span></code></a>, <a class="reference internal" href="buffer-producer.html#_CPPv415BBufferProducer" title="BBufferProducer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferProducer</span></code></a>, etc), you
always need to call through to <span class="hmethod">BMediaNode::HandleMessage()</span> from
your node’s implementation of <span class="hmethod">HandleMessage()</span>. This is crucial,
to be sure that every ancestor of your node gets to look at the message and
attempt to process it.</p>
<p>For example, if your node inherits from both <a class="reference internal" href="buffer-producer.html#_CPPv415BBufferProducer" title="BBufferProducer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferProducer</span></code></a>
and <a class="reference internal" href="buffer-consumer.html#_CPPv415BBufferConsumer" title="BBufferConsumer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferConsumer</span></code></a>, you should call
<a class="reference internal" href="buffer-producer.html#_CPPv4N15BBufferProducer13HandleMessageE5int32PKv6size_t" title="BBufferProducer::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BBufferProducer::HandleMessage()</span></code></a> and
<a class="reference internal" href="buffer-consumer.html#_CPPv4N15BBufferConsumer13HandleMessageE5int32PKv6size_t" title="BBufferConsumer::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BBufferConsumer::HandleMessage()</span></code></a>, <span class="hmethod">then BMediaNode::HandleMessage()</span>, like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">status_t</span><span class="w"> </span><span class="nf">MyBufferProducerConsumer::HandleMessage</span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">message</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">message</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SOME_THING_I_DO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">DoWhatever</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BBufferConsumer</span><span class="o">::</span><span class="n">HandleMessage</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">BBufferProducer</span><span class="o">::</span><span class="n">HandleMessage</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">BMediaNode</span><span class="o">::</span><span class="n">HandleMessage</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">BMediaNode</span><span class="o">::</span><span class="n">HandleBadMessage</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#_CPPv4N10BMediaNode16HandleBadMessageE5int32PKv6size_t" title="BMediaNode::HandleBadMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BMediaNode::HandleBadMessage()</span></code></a> is called if none of
the <span class="hmethod">HandleMessage()</span> implementations accept the message.</p>
<p>Values of message between 0x60000000 and 0x7FFFFFFF are available for use
by applications. Values below 0x60000000 are reserved for use by the Media
Kit, and typically correspond to specific virtual hook functions within
your node. If you can show just cause for needing to know the message value
for a particular hook, you can try emailing devsupport&#64;be.com and see if we
agree with you, in which case we may share that information.</p>
<p>Don’t reverse-engineer the message values; if you really need to know, ask
us. Otherwise, we won’t know that a particular message code number
shouldn’t be changed. In general, it’s a bad idea to rely on specific
values, although there may be cases in which it’s necessary.</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>The message was dispatched.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_ERROR</span></code></p></td>
<td><p>The message couldn’t be dispatched, possibly because it doesn’t correspond
to a hook function.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4NK10BMediaNode2IDEv">
</section>
<h3>
ID()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">media_node_id</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">ID</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>Returns the <span class="xref std std-ref">media_node_id</span> assigned to the node by the Media Server.
The result is 0 if the node hasn’t been registered yet, and negative if an
error occurred while attempting to register the node.</p>
<section id="_CPPv4NK10BMediaNode5KindsEv">
</section>
<h3>
Kinds()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">uint64</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Kinds</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>Returns a bit mask indicating what interfaces the node implements. See
<span class="xref std std-ref">node_kind</span> for a list of valid interface kinds.</p>
<section id="_CPPv4NK10BMediaNode4NameEv">
</section>
<h3>
Name()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Name</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>Returns a human-readable string specifying the node’s name. This pointer
is only valid until you <a class="reference internal" href="#_CPPv4N10BMediaNode7ReleaseEv" title="BMediaNode::Release"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Release()</span></code></a> the
node; after that, the pointer may point into empty space.</p>
<section id="_CPPv4N10BMediaNode12NewChangeTagEv">
</section>
<h3>
NewChangeTag()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">static</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">NewChangeTag</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>This function, intended primarily for use by <a class="reference internal" href="buffer-consumer.html#_CPPv415BBufferConsumer" title="BBufferConsumer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferConsumer</span></code></a>
nodes, creates and returns a new change tag value.</p>
<section id="_CPPv4NK10BMediaNode4NodeEv">
</section>
<h3>
Node()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">media_node</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Node</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>Returns the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">media_node</span></code> structure that will be
used by an application when accessing this node via the media roster.</p>
<section id="_CPPv4N10BMediaNode14NodeRegisteredEv">
</section>
<h3>
NodeRegistered()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">NodeRegistered</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>The Media Server calls this hook function after the node has been
registered.</p>
<section id="_CPPv4NK10BMediaNode11NodeStoppedE9bigtime_t">
</section>
<h3>
NodeStopped()</h3><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">NodeStopped</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">whenPerformanceTime</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>When you’ve finished handling a stop request (buffers will no longer be
flowing), call this function. If anyone is listening for stop notifications
from you, they’ll be notified. The <span class="hparameter">whenPerformanceTime</span> argument
should be the performance time of the stop command that was handled.</p>
<p>Anyone listening for node stop messages will be notified; this lets
applications running in offline (rendering) mode know when the node has
actually completed its work.</p>
<p>If your node is a <a class="reference internal" href="buffer-producer.html#_CPPv415BBufferProducer" title="BBufferProducer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferProducer</span></code></a>, downstream consumers will
be notified that your node stopped (automatically, no less) through the
<code class="docutils literal notranslate"><span class="pre">BBufferConsumer::ProducerDataStatus(B_PRODUCER_STOPPED)</span></code> call. This lets
offline rendering nodes know when each of their inputs have no more data to
send for the current roll.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>This is especially important for nodes that can be run in
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OFFLINE</span></code> mode.</p>
</div>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>No error.</p></td>
</tr>
<tr class="row-odd"><td><p>Other errors.</p></td>
<td><p>Unable to communicate with the Media Server, or an  error occurred
communicating with other nodes.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4N10BMediaNode7PrerollEv">
</section>
<h3>
Preroll()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Preroll</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>This hook function may be called before your node receives a
<a class="reference internal" href="#_CPPv4N10BMediaNode5StartE9bigtime_t" title="BMediaNode::Start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Start()</span></code></a> message if the application using
the node calls <a class="reference internal" href="media-roster.html#_CPPv4N12BMediaRoster11PrerollNodeERK10media_node" title="BMediaRoster::PrerollNode"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BMediaRoster::PrerollNode()</span></code></a>. This gives the node a
chance to prepare the media so that when the media is started, the response
is as fast as possible.</p>
<section id="_CPPv4N10BMediaNode11ReportErrorE10node_errorPK8BMessage">
</section>
<h3>
ReportError()</h3><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">ReportError</span><span class="sig-paren">(</span><span class="n">node_error</span><span class="w"> </span><span class="n sig-param">whichError</span>, <span class="k">const</span><span class="w"> </span><a class="reference internal" href="../application/message.html#_CPPv48BMessage" title="BMessage"><span class="n">BMessage</span></a><span class="w"> </span><span class="p">*</span><span class="n sig-param">info</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">NULL</span><span class="sig-paren">)</span></pre><p>Transmits the error code specified by <span class="hparameter">whichError</span> to anyone
that’s receiving notifications from this node (see
<a class="reference internal" href="media-roster.html#_CPPv4N12BMediaRoster13StartWatchingERK10BMessenger" title="BMediaRoster::StartWatching"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BMediaRoster::StartWatching()</span></code></a> and
<a class="reference internal" href="media-roster.html#_CPPv4N12BMediaRoster12StopWatchingERK10BMessenger" title="BMediaRoster::StopWatching"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BMediaRoster::StopWatching()</span></code></a> on  ). If <span class="hparameter">info</span> isn’t
<span class="cpp-expr sig sig-inline cpp"><span class="n">NULL</span></span>, it’s used as a model message for the error notification
message.</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>The error report was sent without error.</p></td>
</tr>
<tr class="row-odd"><td><p>BMessageerrors.</p></td>
<td><p>The message couldn’t be sent.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4N10BMediaNode16RequestCompletedERK18media_request_info">
</section>
<h3>
RequestCompleted()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">RequestCompleted</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="n">media_request_info</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">info</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">NULL</span><span class="sig-paren">)</span></pre><p>This function is called whenever a request issued by the node is
completed. The <span class="hparameter">info</span> structure describes the results of the
request.</p>
<p>The <span class="hparameter">change_tag</span> field in the <span class="hparameter">info</span> structure identifies
the request that has been completed; this is the same value passed into the
function that initiated the request.</p>
<p>Return <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code> if you’re happy, otherwise return an
appropriate error code.</p>
<section id="_CPPv4NK10BMediaNode7RunModeEv">
</section>
<h3>
RunMode()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">run_mode</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">RunMode</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p><span class="hmethod">RunMode()</span> returns the node’s current <span class="xref std std-ref">run_mode</span> setting.</p>
<p>The <span class="hmethod">SetRunMode()</span> hook function is called when someone requests
that your node’s run mode be changed.</p>
<section id="_CPPv4N10BMediaNode4SeekE9bigtime_t9bigtime_t">
</section>
<h3>
Seek()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Seek</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">mediaTime</span>, <span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">performanceTime</span><span class="sig-paren">)</span></pre><p>This hook function is called when a node is asked to seek to the specified
<span class="hparameter">mediaTime</span> by a call to the <a class="reference internal" href="media-roster.html#_CPPv412BMediaRoster" title="BMediaRoster"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BMediaRoster</span></code></a>.</p>
<p>The specified <span class="hparameter">performanceTime</span>, the time at which the node should
begin the seek operation, may be in the future.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>Your node is required to queue at least one each of start, stop, and seek
requests, so that applications can establish, for example, both the start
and stop time without having to monitor your node’s progress. The actual
size of these three queues is up to you. When the specified time arrives,
the request should be filled.</p>
</div>
<p>A <span class="hparameter">mediaTime</span> value of 0 indicates the beginning of the media
data.</p>
<section id="_CPPv4N10BMediaNode13SetTimeSourceEP11BTimeSource">
</section>
<section id="_CPPv4NK10BMediaNode10TimeSourceEv">
</section>
<h3>
SetTimeSource(), TimeSource()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">SetTimeSource</span><span class="sig-paren">(</span><a class="reference internal" href="time-source.html#_CPPv411BTimeSource" title="BTimeSource"><span class="n">BTimeSource</span></a><span class="w"> </span><span class="p">*</span><span class="n sig-param">timeSource</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="time-source.html#_CPPv411BTimeSource" title="BTimeSource"><span class="n">BTimeSource</span></a><span class="w"> </span><span class="p">*</span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">TimeSource</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>The <span class="hmethod">SetTimeSource()</span> hook function is called when someone has
requested that the node be slaved to a new time source. Augment this
function to make whatever adjustments you need to make to operate at the
new time scale.</p>
<p><span class="hmethod">TimeSource()</span> returns a pointer to the <a class="reference internal" href="time-source.html#_CPPv411BTimeSource" title="BTimeSource"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BTimeSource</span></code></a>
to which the node is currently slaved. If no time source has been
explicitly requested, the system time source is in use, and that’s what
gets returned.</p>
<div class="warning admonition">
<p class="admonition-title">Warning</p>
<p>The <a class="reference internal" href="time-source.html#_CPPv411BTimeSource" title="BTimeSource"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BTimeSource</span></code></a> object returned by <span class="hmethod">TimeSource()</span> is
only valid until the next call to <a class="reference internal" href="#_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t" title="BMediaNode::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HandleMessage()</span></code></a> on that object. Therefore, if your node runs
more than one thread, you need to serialize calls to
<span class="hmethod">TimeSource()</span> (as well as usage of the returned objects) with
calls to <a class="reference internal" href="#_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t" title="BMediaNode::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HandleMessage()</span></code></a> This isn’t
a problem if you follow the recommended policy of running a single thread
that monitors the service port with <span class="xref std std-ref">read_port_etc()</span> and calls
<a class="reference internal" href="#_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t" title="BMediaNode::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HandleMessage()</span></code></a> only when a message
is actually received.</p>
</div>
<section id="_CPPv4N10BMediaNode5StartE9bigtime_t">
</section>
<h3>
Start()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Start</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">performanceTime</span><span class="sig-paren">)</span></pre><p>This hook function is called when a node is started by a call to the
<a class="reference internal" href="media-roster.html#_CPPv412BMediaRoster" title="BMediaRoster"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BMediaRoster</span></code></a>.</p>
<p>The specified <span class="hparameter">performanceTime</span>, the time at which the node should
start running, may be in the future.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>Your node is required to queue at least one each of start, stop, and seek
requests, so that applications can establish, for example, both the start
and stop time without having to monitor your node’s progress. The actual
size of these three queues is up to you. When the specified time arrives,
the request should be filled.</p>
</div>
<section id="_CPPv4N10BMediaNode4StopE9bigtime_tb">
</section>
<h3>
Stop()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">Stop</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">performanceTime</span>, <span class="kt">bool</span><span class="w"> </span><span class="n sig-param">immediate</span><span class="sig-paren">)</span></pre><p>This hook function is called when a node is stopped by a call to the
<a class="reference internal" href="media-roster.html#_CPPv412BMediaRoster" title="BMediaRoster"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BMediaRoster</span></code></a>.</p>
<p>The specified <span class="hparameter">performanceTime</span>, the time at which the node should
stop, may be in the future.</p>
<p>If <span class="hparameter">immediate</span> is <span class="cpp-expr sig sig-inline cpp"><span class="k">true</span></span>, your node should ignore the
<span class="hparameter">performanceTime</span> value and synchronously stop performance. When
<span class="hmethod">Stop()</span> returns, you’re promising not to write into any
<a class="reference internal" href="buffer.html#_CPPv47BBuffer" title="BBuffer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBuffer</span></code></a>s you may have received from your downstream consumers,
and you promise not to send any more buffers until <a class="reference internal" href="#_CPPv4N10BMediaNode5StartE9bigtime_t" title="BMediaNode::Start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Start()</span></code></a> is called again.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>Your node is required to queue at least one each of start, stop, and seek
requests, so that applications can establish, for example, both the start
and stop time without having to monitor your node’s progress. The actual
size of these three queues is up to you. When the specified time arrives,
the request should be filled.</p>
</div>
<p>Nodes must recycle all buffers they may be holding onto when they’re
stopped.</p>
<section id="_CPPv4N10BMediaNode8TimeWarpE9bigtime_t9bigtime_t">
</section>
<h3>
TimeWarp()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">TimeWarp</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">atRealTime</span>, <span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">newPerformanceTime</span><span class="sig-paren">)</span></pre><p>This hook function is called when the time source to which the node is
slaved is repositioned (via a seek operation) such that there will be a
sudden jump in the performance time progression as seen by the node. The
<span class="hparameter">newPerformanceTime</span> argument indicates the new performance time;
the change should occur at the real time specified by the
<span class="hparameter">atRealTime</span> argument.</p>
<p>The node should respond to this call by preparing for this change, so a
serious stutter, failure, or acceleration in performance doesn’t occur.
Appropriate measures should be taken to minimize the impact on the
performance quality; for example, a segment of the sound could be looped or
skipped smoothly.</p>
<p>Your implementation of <span class="hmethod">TimeWarp()</span> should call through to
<span class="hmethod">BMediaNode::TimeWarp()</span> as well as all other inherited forms of
<span class="hmethod">TimeWarp()</span>.</p>
<section id="_CPPv4N10BMediaNode14WaitForMessageE9bigtime_t6uint32Pv">
</section>
<h3>
WaitForMessage()</h3><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv410BMediaNode" title="BMediaNode"><span class="n">BMediaNode</span></a><span class="p">::</span></span><span class="n">WaitForMessage</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">waitUntil</span>, <span class="n">uint32</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span>, <span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">_reserved_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">NULL</span><span class="sig-paren">)</span></pre><p>This function waits until either real time specified by
<span class="hparameter">waitUntil</span> or a message is received on the control port.. The
<span class="hparameter">flags</span> are currently unused and should be 0.</p>
<p>When a message is received, the appropriate <a class="reference internal" href="#_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t" title="BMediaNode::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HandleMessage()</span></code></a> calls are made given the class derivation of
the node:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#_CPPv4N10BMediaNode13HandleMessageE5int32PKv6size_t" title="BMediaNode::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BMediaNode::HandleMessage()</span></code></a> is always called first.</p></li>
<li><p>If the node is derived from <a class="reference internal" href="buffer-producer.html#_CPPv415BBufferProducer" title="BBufferProducer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferProducer</span></code></a>, and the message
hasn’t been handled yet, <a class="reference internal" href="buffer-producer.html#_CPPv4N15BBufferProducer13HandleMessageE5int32PKv6size_t" title="BBufferProducer::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BBufferProducer::HandleMessage()</span></code></a> is
called.</p></li>
<li><p>If the node is derived from <a class="reference internal" href="buffer-consumer.html#_CPPv415BBufferConsumer" title="BBufferConsumer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BBufferConsumer</span></code></a>, and the message
hasn’t been handled yet, <a class="reference internal" href="buffer-consumer.html#_CPPv4N15BBufferConsumer13HandleMessageE5int32PKv6size_t" title="BBufferConsumer::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BBufferConsumer::HandleMessage()</span></code></a> is
called.</p></li>
<li><p>If the node is derived from <a class="reference internal" href="file-interface.html#_CPPv414BFileInterface" title="BFileInterface"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BFileInterface</span></code></a>, and the message
hasn’t been handled yet, <a class="reference internal" href="file-interface.html#_CPPv4N14BFileInterface13HandleMessageE5int32PKv6size_t" title="BFileInterface::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BFileInterface::HandleMessage()</span></code></a> is
called.</p></li>
<li><p>If the node is derived from <a class="reference internal" href="controllable.html#_CPPv413BControllable" title="BControllable"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BControllable</span></code></a>, and the message
hasn’t been handled yet, <a class="reference internal" href="controllable.html#_CPPv4N13BControllable13HandleMessageE5int32PKvP6size_t" title="BControllable::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BControllable::HandleMessage()</span></code></a> is
called.</p></li>
<li><p>If the node is derived from <a class="reference internal" href="time-source.html#_CPPv411BTimeSource" title="BTimeSource"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BTimeSource</span></code></a>, and the message
hasn’t been handled yet, <a class="reference internal" href="time-source.html#_CPPv4N11BTimeSource13HandleMessageE5int32PKv6size_t" title="BTimeSource::HandleMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BTimeSource::HandleMessage()</span></code></a> is called.</p></li>
<li><p>If the message still hasn’t been handled, the most-derived interface’s
<span class="hmethod">HandleMessage()</span> function is called.</p></li>
<li><p>If the message hasn’t been handled, <a class="reference internal" href="#_CPPv4N10BMediaNode16HandleBadMessageE5int32PKv6size_t" title="BMediaNode::HandleBadMessage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">HandleBadMessage()</span></code></a> is called.</p></li>
</ul>
<p>Once this has been done, <span class="hmethod">WaitForMessage()</span> returns. As you can
see, this can be called from your control port to handle much of the work
of processing received messages.</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>A message has occurred within the given time period.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_TIMED_OUT</span></code></p></td>
<td><p>The time <span class="hparameter">waitUntil</span> has arrived without a message being received.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="constants">
<h2>Constants<a class="headerlink" href="#constants" title="Permalink to this heading">¶</a></h2>
<section id="node-error">
<h3>node_error<a class="headerlink" href="#node-error" title="Permalink to this heading">¶</a></h3>
<p>Declared in: media/MediaNode.h</p>
<p>The <span class="htype">node_error</span> type defines the errors a node can transmit to
<a class="reference internal" href="../application/messenger.html#_CPPv410BMessenger" title="BMessenger"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BMessenger</span></code></a>s that have registered to watch the node.</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_FAILED_START</span></code></p></td>
<td><p>The node failed on a <a class="reference internal" href="#_CPPv4N10BMediaNode5StartE9bigtime_t" title="BMediaNode::Start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Start()</span></code></a> request.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_FAILED_STOP</span></code></p></td>
<td><p>The node failed on a <a class="reference internal" href="#_CPPv4N10BMediaNode4StopE9bigtime_tb" title="BMediaNode::Stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Stop()</span></code></a> request.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_FAILED_SEEK</span></code></p></td>
<td><p>The node failed on a <a class="reference internal" href="#_CPPv4N10BMediaNode4SeekE9bigtime_t9bigtime_t" title="BMediaNode::Seek"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Seek()</span></code></a> request.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_FAILED_SET_RUN_MODE</span></code></p></td>
<td><p>The node’s <span class="xref std std-ref">run_mode</span> couldn’t be set.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_FAILED_TIME_WARP</span></code></p></td>
<td><p>The node couldn’t fulfill a time warp request.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_FAILED_PREROLL</span></code></p></td>
<td><p>The node failed on a <a class="reference internal" href="#_CPPv4N10BMediaNode7PrerollEv" title="BMediaNode::Preroll"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Preroll()</span></code></a> request.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_FAILED_SET_TIME_SOURCE_FOR</span></code></p></td>
<td><p>The node’s time source couldn’t be changed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NODE_IN_DISTRESS</span></code></p></td>
<td><p>The node is suffering in general.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="run-mode">
<h3>run_mode<a class="headerlink" href="#run-mode" title="Permalink to this heading">¶</a></h3>
<p>Declared in: media/MediaNode.h</p>
<p>The <span class="htype">run_mode</span> type indicates how a node should cope if its
performance rate deviates from the desired rate.</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OFFLINE</span></code></p></td>
<td><p>Keep data accurate, even if the performance lags or runs too fast. This is
typically used when rendering to disk.</p>
<p>When in offline mode the node doesn’t need to worry about processing
buffers at any particular time. Each buffer’s performance time should be
derived from the time stamped on the buffer, rather than from a
<a class="reference internal" href="time-source.html#_CPPv411BTimeSource" title="BTimeSource"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BTimeSource</span></code></a>. In fact, you’ll usually want to call
<span class="xref std std-ref">set_thread_priority()</span> to set your node’s processing threads to a low
priority while the node is in offline mode. This lets software render media
to disk in an efficient manner, letting the user continue to work while the
render occurs in the background.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RECORDING</span></code></p></td>
<td><p>Time-stamped buffers are being received from a node capturing them from
the real world; these buffers are guaranteed to have a time stamp in the
past (they’re always “late”).</p>
<p>Recording mode should be used when data is being sampled from a physical
input device. These devices always deliver buffers whose time stamps are in
the past (they’re stamped with the time at which they were sampled, which
is of course in the past, unless you’ve stolen a time machine from a
professor from the 27th century, in which case you’re probably running BeOS
R127.1 and this book is woefully obsolete).</p>
<p>Using <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RECORDING</span></code> mode serves to warn other nodes that
the time stamps will be in the past.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_DECREASE_PRECISION</span></code></p></td>
<td><p>If the performance starts to lag, try to catch up.</p>
<p>In <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_DECREASE_PRECISION</span></code> mode, your node should attempt
to catch up if it falls behind, by playing buffers of media data faster
than normal. For audio, this might mean playing back at a higher sampling
rate; for video, the frame rate might be temporarily boosted.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_INCREASE_LATENCY</span></code></p></td>
<td><p>If the performance starts to lag, increase playout delay so buffers are
delivered with less time to spare before they’re needed.</p>
<p>If your node gets behind in the <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_INCREASE_LATENCY</span></code> run
mode, your node should increase its internal latency measurement and send
call the <a class="reference internal" href="buffer-producer.html#_CPPv4N15BBufferProducer18LateNoticeReceivedERK12media_source9bigtime_t9bigtime_t" title="BBufferProducer::LateNoticeReceived"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">LateNoticeReceived()</span></code></a> function in anyone above your node
in the media stream.</p>
<p>Your node should then try to produce each buffer earlier before the
buffer’s performance time from that point on, so there’s more time for the
buffers to reach their destination.</p>
<p>This mode is intended to compensate for data streams in which throughput
can vary over time. For example, if media data is being streamed over a
network, traffic fluctuations may require your node to adapt by adding more
buffering (latency).</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_DROP_DATA</span></code></p></td>
<td><p>If the performance starts to lag, skip data.</p>
<p>When in <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_DROP_DATA</span></code> mode, your node should simply skip
buffers if if falls behind. Note that you still receive the buffers, but
you should ignore any that you must in order to keep playing as many
buffers as possible at the correct performance times.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


        <div class="clearer"></div>
      </div>
          </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="media-formats.html">BMediaFormats</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="media-roster.html">BMediaRoster</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Haiku, Inc..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>