
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>BNetEndpoint &#8212; The Haiku Book  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/code.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Network Sockets" href="network-sockets.html" />
    <link rel="prev" title="BNetDebug" href="net-debug.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>API Documentation</span></a></h1>
        <h2 class="heading"><span>BNetEndpoint</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="net-debug.html">BNetDebug</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="network-sockets.html">Network Sockets</a>&#160;&#160;»
        </p>

      </div>
        
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">BNetEndpoint</a><ul>
<li><a class="reference internal" href="#constructor-and-destructor">Constructor and Destructor</a><ul>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint12BNetEndpointEi">BNetEndpoint</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpointD0Ev">~BNetEndpoint</a></li>
</ul>
</li>
<li><a class="reference internal" href="#member-functions">Member Functions</a><ul>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint4BindERK11BNetAddress">Bind</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint5CloseEv">Close</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint7ConnectERK11BNetAddress">Connect</a></li>
<li><a class="reference internal" href="#_CPPv4NK12BNetEndpoint5ErrorEv">Error</a></li>
<li><a class="reference internal" href="#_CPPv4NK12BNetEndpoint8ErrorStrEv">ErrorStr</a></li>
<li><a class="reference internal" href="#_CPPv4NK12BNetEndpoint9InitCheckEv">InitCheck</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint13IsDataPendingE9bigtime_t">IsDataPending</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint6ListenEi">Listen</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint6AcceptE5int32">Accept</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint9LocalAddrEv">LocalAddr</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint10RemoteAddrEv">RemoteAddr</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint7ReceiveEPKv6size_ti">Receive</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint11ReceiveFromEPKv6size_tRK11BNetAddressi">ReceiveFrom</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint4SendEPKv6size_ti">Send</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint6SendToEPKv6size_tRK11BNetAddressi">SendTo</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint9SetOptionE5int325int32PKvj">SetOption</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint14SetNonBlockingEb">SetNonBlocking</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint12SetReuseAddrEb">SetReuseAddr</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint11SetProtocolEi">SetProtocol</a></li>
<li><a class="reference internal" href="#_CPPv4N12BNetEndpoint10SetTimeoutE9bigtime_t">SetTimeout</a></li>
<li><a class="reference internal" href="#_CPPv4NK12BNetEndpoint6SocketEv">Socket</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operators">Operators</a></li>
</ul>
</li>
</ul>

  </div>

        </div>
      </div>
          <div class="bodywrapper">
      <div class="content" role="main">
        
  <section id="bnetendpoint">
<h1>BNetEndpoint<a class="headerlink" href="#bnetendpoint" title="Permalink to this heading">¶</a></h1>
<section id="constructor-and-destructor">
<h2>Constructor and Destructor<a class="headerlink" href="#constructor-and-destructor" title="Permalink to this heading">¶</a></h2>
<section id="_CPPv4N12BNetEndpoint12BNetEndpointEi">
</section>
<h3>
BNetEndpoint()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv4N12BNetEndpoint12BNetEndpointEi" title="BNetEndpoint::BNetEndpoint"><span class="n">BNetEndpoint</span></a><span class="p">::</span></span><span class="n">BNetEndpoint</span><span class="sig-paren">(</span><span class="kt">int</span><span class="w"> </span><span class="n sig-param">protocol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">SOCK_STREAM</span><span class="sig-paren">)</span><br /><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv4N12BNetEndpoint12BNetEndpointERK12BNetEndpoint" title="BNetEndpoint::BNetEndpoint"><span class="n">BNetEndpoint</span></a><span class="p">::</span></span><span class="n">BNetEndpoint</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><a class="reference internal" href="#_CPPv4N12BNetEndpoint12BNetEndpointERK12BNetEndpoint" title="BNetEndpoint::BNetEndpoint"><span class="n">BNetEndpoint</span></a><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">from</span><span class="sig-paren">)</span><br /><span class="sig-prename descclassname"><a class="reference internal" href="#_CPPv4N12BNetEndpoint12BNetEndpointEP8BMessage" title="BNetEndpoint::BNetEndpoint"><span class="n">BNetEndpoint</span></a><span class="p">::</span></span><span class="n">BNetEndpoint</span><span class="sig-paren">(</span><span class="n">BMessage</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">archive</span><span class="sig-paren">)</span></pre><p>Creates a <span class="hclass">BNetEndpoint</span> representing a
network connection endpoint on the local system. After construction, you
must call
<a class="reference internal" href="#_CPPv4NK12BNetEndpoint9InitCheckEv" title="BNetEndpoint::InitCheck"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">InitCheck()</span></code></a>
to ensure that no errors occurred during setup.
The <span class="hparameter">protocol</span> argument lets you specify
whether the <span class="hclass">BNetEndpoint</span> will use a stream
socket (<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>) or a datagram socket
(<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code>).
By default, I/O is blocking and address reusing is off. You can change
these by calling
<a class="reference internal" href="#_CPPv4N12BNetEndpoint14SetNonBlockingEb" title="BNetEndpoint::SetNonBlocking"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetNonBlocking()</span></code></a> and
<a class="reference internal" href="#_CPPv4N12BNetEndpoint12SetReuseAddrEb" title="BNetEndpoint::SetReuseAddr"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetReuseAddr()</span></code></a>.</p>
<section id="_CPPv4N12BNetEndpointD0Ev">
</section>
<h3>
~BNetEndpoint()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">~BNetEndpoint</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>A typical destructor.</p>
</section>
<section id="member-functions">
<h2>Member Functions<a class="headerlink" href="#member-functions" title="Permalink to this heading">¶</a></h2>
<section id="_CPPv4N12BNetEndpoint4BindERK11BNetAddress">
</section>
<h3>
Bind()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">status_t</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Bind</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">address</span><span class="sig-paren">)</span><br /><span class="k">virtual</span><span class="w"> </span><span class="n">status_t</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Bind</span><span class="sig-paren">(</span><span class="kt">int</span><span class="w"> </span><span class="n sig-param">port</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span></pre><p>Binds the <span class="hclass">BNetEndpoint</span> to a
specific local address. That address can be
specified by using a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetAddress</span></code>
or a simple <span class="hparameter">port</span> number. This selects
the port that will handle the local end of the connection.
If your <span class="hclass">BNetEndpoint</span> is using a stream
protocol and is going to be listening for connections, you must call
<span class="hmethod">Bind()</span>.
If your stream <span class="hclass">BNetEndpoint</span> is a client,
it doesn’t have to call <span class="hmethod">Bind()</span> but you can if
you want to. There aren’t any significant benefits to doing so,
however.
A stream accept <span class="hclass">BNetEndpoint</span>s must not
be bound.
Datagram <span class="hclass">BNetEndpoint</span>s that are going to
receive data must be bound; datagram
<span class="hclass">BNetEndpoint</span>s that will only be sending data
don’t have to be. However, if an endpoint will both send and receive, it
must be bound.
If you don’t specify an <span class="hparameter">address</span> or
<span class="hparameter">port</span> number, or specify a
<span class="hparameter">port</span> number of 0,
<span class="hmethod">Bind()</span> will bind the
<span class="hclass">BNetEndpoint</span> to a random local port. You can
determine which one by calling
<a class="reference internal" href="#_CPPv4N12BNetEndpoint9LocalAddrEv" title="BNetEndpoint::LocalAddr"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">LocalAddr()</span></code></a>.
The only way to unbind a <span class="hclass">BNetEndpoint</span>
from an address or port is to close the endpoint.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>The address was successfully bound to.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code></p></td>
<td><p>An error occurred.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4N12BNetEndpoint5CloseEv">
</section>
<h3>
Close()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Close</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>Closes the connection, if there is one. If there’s unread data buffered
up, it’s disposed of.</p>
<section id="_CPPv4N12BNetEndpoint7ConnectERK11BNetAddress">
</section>
<h3>
Connect()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">status_t</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Connect</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">address</span><span class="sig-paren">)</span><br /><span class="k">virtual</span><span class="w"> </span><span class="n">status_t</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Connect</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">address</span>, <span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n sig-param">port</span><span class="sig-paren">)</span></pre><p>Opens a connection to the specified remote system. The system’s address
can be specified by either using a
<span class="hclass">BNetAddress</span>
or by specifying the IP
address or domain name and port number. For example, to connect to the
Megaburger, Inc. web server, your software would call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">myEndpoint</span><span class="o">-&gt;</span><span class="n">Connect</span><span class="p">(</span><span class="s2">&quot;www.megaburger.com&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">B_OK</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">/*</span> <span class="n">error</span> <span class="n">occurred</span> <span class="o">*/</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
   <span class="o">/*</span> <span class="nb">all</span> <span class="ow">is</span> <span class="n">well</span><span class="p">,</span> <span class="n">connection</span> <span class="ow">is</span> <span class="nb">open</span> <span class="o">*/</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>The connection was opened.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code></p></td>
<td><p>An error occurred.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4NK12BNetEndpoint5ErrorEv">
</section>
<section id="_CPPv4NK12BNetEndpoint8ErrorStrEv">
</section>
<h3>
Error(), ErrorStr()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">int</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Error</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">ErrorStr</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p><span class="hmethod">Error()</span> returns the integer error code for the last send or receive
error. If you receive a <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code> result from a send or receive function,
you can find out the specific error using this function.
<span class="hmethod">ErrorStr()</span> returns a pointer to a text string describing the error; this
string isn’t yours, so don’t try to free() it.</p>
<section id="_CPPv4NK12BNetEndpoint9InitCheckEv">
</section>
<h3>
InitCheck()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">status_t</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">InitCheck</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>Returns a status_t indicating whether or not the object was successfully
instantiated.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>The <span class="hclass">BNetEndpoint</span> was constructed without error.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code></p></td>
<td><p>An error occurred during construction.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4N12BNetEndpoint13IsDataPendingE9bigtime_t">
</section>
<h3>
IsDataPending()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">IsDataPending</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">timeout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span></pre><p>Returns <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">true</span></code> if there’s data waiting to be received, otherwise returns
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">false</span></code>. If you specify a <span class="hparameter">timeout</span> other than 0, the function will block
until either data is available or the timeout period elapses.</p>
<section id="_CPPv4N12BNetEndpoint6ListenEi">
</section>
<section id="_CPPv4N12BNetEndpoint6AcceptE5int32">
</section>
<h3>
Listen(), Accept()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">status_t</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Listen</span><span class="sig-paren">(</span><span class="kt">int</span><span class="w"> </span><span class="n sig-param">backlog</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">5</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">BNetEndpoint</span><span class="w"> </span><span class="p">*</span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Accept</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="n sig-param">timeout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">-</span><span class="m">1</span><span class="sig-paren">)</span></pre><p><span class="hmethod">Listen()</span> tells the
<span class="hclass">BNetEndpoint</span> to begin listening for incoming
connection attempts on its local port. These attempts are queued; up to
backlog attempts can be in the queue at any time. If more attempts are
backlogged than that, the later attempts will be rejected until there’s
room in the queue.
You can accept an incoming connection attempt by calling <span class="hmethod">Accept()</span>. If
there are no connection attempts queued up, this function returns <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">NULL</span></code>.
If there are connection attempts in the queue, a new <span class="hclass">BNetEndpoint</span> object
is created with the connection between your local port and the remote
system opened, and that <span class="hclass">BNetEndpoint</span> is returned to you.
The new connection is yours to do with as you please. When you’re
finished with the connection, you must delete the returned <span class="hclass">BNetEndpoint</span>.
Typically your listener thread will look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">long</span> <span class="n">MyListener</span><span class="p">(</span><span class="n">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">BNetEndpoint</span> <span class="n">endpoint</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">InitCheck</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">B_OK</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="o">/*</span> <span class="n">bind</span> <span class="n">to</span> <span class="n">the</span> <span class="n">desired</span> <span class="n">port</span> <span class="o">*/</span>
   <span class="n">endpoint</span><span class="o">.</span><span class="n">Bind</span><span class="p">(</span><span class="n">portNumber</span><span class="p">);</span>
   <span class="o">/*</span> <span class="n">listen</span> <span class="k">for</span> <span class="n">connections</span> <span class="o">*/</span>
   <span class="n">endpoint</span><span class="o">.</span><span class="n">Listen</span><span class="p">();</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">keepListening</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">BNetEndpoint</span><span class="o">*</span> <span class="n">connect</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
      <span class="n">connect</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">Accept</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">)</span> <span class="p">{</span>
         <span class="o">/*</span> <span class="n">call</span> <span class="n">a</span> <span class="n">function</span> <span class="n">do</span> <span class="n">the</span> <span class="n">work</span> <span class="o">*/</span>
         <span class="n">handle_connection</span><span class="p">(</span><span class="n">connect</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
         <span class="n">delete</span> <span class="n">connect</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">endpoint</span><span class="o">.</span><span class="n">Close</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>Success.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code></p></td>
<td><p>Failure.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4N12BNetEndpoint9LocalAddrEv">
</section>
<section id="_CPPv4N12BNetEndpoint10RemoteAddrEv">
</section>
<h3>
LocalAddr(), RemoteAddr()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">LocalAddr</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">RemoteAddr</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>These functions return a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetAddress</span></code>
representing the local or remote system on the connection.
<span class="hmethod">LocalAddr()</span> returns the address of the local
machine, and <span class="hmethod">RemoteAddr()</span> (amazingly enough)
returns the address of the remote system.
If there isn’t a remote connection, <span class="hmethod">RemoteAddr()</span> will return a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetAddress</span></code>
indicating an IP address of 0.0.0.0.</p>
<section id="_CPPv4N12BNetEndpoint7ReceiveEPKv6size_ti">
</section>
<section id="_CPPv4N12BNetEndpoint11ReceiveFromEPKv6size_tRK11BNetAddressi">
</section>
<h3>
Receive(), ReceiveFrom()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Receive</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">buffer</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span><br /><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Receive</span><span class="sig-paren">(</span><span class="n">BNetBuffer</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">buffer</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">ReceiveFrom</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">buffer</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span>, <span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">from</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span><br /><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">ReceiveFrom</span><span class="sig-paren">(</span><span class="n">BNetBuffer</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">buffer</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span>, <span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">from</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span></pre><p><span class="hmethod">Receive()</span> receives a buffer of data from the remote end of the
connection. If there’s no connection established, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code> is returned
immediately. Up to <span class="hparameter">size</span> bytes of data are received.
<span class="hmethod">ReceiveFrom()</span> receives the buffer
from the remote system specified by the from
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetAddress</span></code>.
<span class="hmethod">ReceiveFrom()</span> only works if the connection is
using a datagram protocol.
The first form of each function function sends an arbitrary buffer of the
specified <span class="hparameter">size</span>, and the second form sends the contents of a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetBuffer</span></code>.
When using a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetBuffer</span></code>,
incoming data is appended to the end of the
buffer, so you can use the same buffer in a loop to buffer incoming data
in chunks until the desired number of bytes have been read.
The <span class="hparameter">flags</span> argument, which is passed on to
the socket.h
<span class="xref std std-ref">recv()</span> or
<span class="xref std std-ref">recvfrom()</span>
function, is currently unused and must be 0.
When you call these functions in blocking mode (which is the default),
they block until there’s data available to receive or a timeout occurs.
The timeout period is set by calling
<a class="reference internal" href="#_CPPv4N12BNetEndpoint10SetTimeoutE9bigtime_t" title="BNetEndpoint::SetTimeout"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetTimeout()</span></code></a>.
You can turn on or off blocking by calling
<a class="reference internal" href="#_CPPv4N12BNetEndpoint14SetNonBlockingEb" title="BNetEndpoint::SetNonBlocking"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetNonBlocking()</span></code></a>.
If you’re in nonblocking mode and
there’s no data waiting, these functions return 0 immediately, indicating
that there’s no data.
These functions return the number of bytes actually received, or -1 if an
error occurred. You can call
<a class="reference internal" href="#_CPPv4NK12BNetEndpoint5ErrorEv" title="BNetEndpoint::Error"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Error()</span></code></a>
to get the specific error that occurred.</p>
<section id="_CPPv4N12BNetEndpoint4SendEPKv6size_ti">
</section>
<section id="_CPPv4N12BNetEndpoint6SendToEPKv6size_tRK11BNetAddressi">
</section>
<h3>
Send(), SendTo()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Send</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">buffer</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span><br /><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Send</span><span class="sig-paren">(</span><span class="n">BNetBuffer</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">buffer</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">SendTo</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">buffer</span>, <span class="n">size_t</span><span class="w"> </span><span class="n sig-param">size</span>, <span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">to</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span><br /><span class="k">virtual</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">SendTo</span><span class="sig-paren">(</span><span class="n">BNetBuffer</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">buffer</span>, <span class="k">const</span><span class="w"> </span><span class="n">BNetAddress</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">to</span>, <span class="kt">int</span><span class="w"> </span><span class="n sig-param">flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="sig-paren">)</span></pre><p><span class="hmethod">Send()</span> sends a buffer of data to the
remote end of the connection. If there’s no connection established,
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code> is returned immediately. In addition, if
the <span class="hclass">BNetEndpoint</span> is configured to use a datagram
protocol, this function fails unless
<a class="reference internal" href="#_CPPv4N12BNetEndpoint7ConnectERK11BNetAddress" title="BNetEndpoint::Connect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Connect()</span></code></a>
has been called, since that function caches the destination address.
<span class="hmethod">SendTo()</span> sends the buffer to the remote system specified by the to
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetAddress</span></code>.
<span class="hmethod">SendTo()</span> only works if the connection is using a datagram
protocol.
The first form of each function function sends an arbitrary buffer of the
specified size, and the second form sends the contents of a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BNetBuffer</span></code>.
The <span class="hparameter">flags</span> argument, which is passed on
to the the socket.h
<span class="xref std std-ref">send()</span> or
<span class="xref std std-ref">sendto()</span>
function, is currently unused and must be 0.
These functions return the number of bytes actually sent, or -1 if an
error occurred. You can call
<a class="reference internal" href="#_CPPv4NK12BNetEndpoint5ErrorEv" title="BNetEndpoint::Error"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Error()</span></code></a>
to get the specific error that occurred.</p>
<section id="_CPPv4N12BNetEndpoint9SetOptionE5int325int32PKvj">
</section>
<section id="_CPPv4N12BNetEndpoint14SetNonBlockingEb">
</section>
<section id="_CPPv4N12BNetEndpoint12SetReuseAddrEb">
</section>
<h3>
SetOption(), SetNonBlocking(), SetReuseAddr()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">int</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">SetOption</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="n sig-param">option</span>, <span class="n">int32</span><span class="w"> </span><span class="n sig-param">level</span>, <span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">data</span>, <span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n sig-param">dataSize</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">int</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">SetNonBlocking</span><span class="sig-paren">(</span><span class="kt">bool</span><span class="w"> </span><span class="n sig-param">enable</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">true</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">int</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">SetReuseAddr</span><span class="sig-paren">(</span><span class="kt">bool</span><span class="w"> </span><span class="n sig-param">enable</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">true</span><span class="sig-paren">)</span></pre><p><span class="hmethod">SetOption()</span> lets you set any option
for the <span class="hclass">BNetEndpoint</span>. This provides
access to the setsockopt() function of the underlying
socket.
<span class="hmethod">SetNonBlocking()</span> controls whether
I/O should block or not. If <span class="hparameter">enable</span> is
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">true</span></code>, the connection will be nonblocking. If
<span class="hparameter">enable</span> is <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">false</span></code>, the
connection will block on I/O calls until the transmission is completed.
<span class="hmethod">SetReuseAddr()</span> controls
whether addresses should be reused or not. If
<span class="hparameter">enable</span> is <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">true</span></code>, addresses
will be reused. If <span class="hparameter">enable</span> is <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">false</span></code>, the
connection won’t reuse addresses.
These functions return 0 if successful; otherwise they return -1.</p>
<section id="_CPPv4N12BNetEndpoint11SetProtocolEi">
</section>
<h3>
SetProtocol()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">status_t</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">SetProtocol</span><span class="sig-paren">(</span><span class="kt">int</span><span class="w"> </span><span class="n sig-param">protocol</span><span class="sig-paren">)</span></pre><p>Sets the protocol type for the connection. Possible values for the
protocol argument are <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code> (to use the stream protocol) or
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code> (for datagram protocol).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code></p></td>
<td><p>The protocol was set successfully.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_ERROR</span></code></p></td>
<td><p>An error occurred setting the protocol.</p></td>
</tr>
</tbody>
</table>
<section id="_CPPv4N12BNetEndpoint10SetTimeoutE9bigtime_t">
</section>
<h3>
SetTimeout()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">void</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">SetTimeout</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">timeout</span><span class="sig-paren">)</span></pre><p>Sets the timeout for calls to
<a class="reference internal" href="#_CPPv4N12BNetEndpoint7ReceiveEPKv6size_ti" title="BNetEndpoint::Receive"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Receive()</span></code></a> and
<a class="reference internal" href="#_CPPv4N12BNetEndpoint11ReceiveFromEPKv6size_tRK11BNetAddressi" title="BNetEndpoint::ReceiveFrom"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ReceiveFrom()</span></code></a>.
If blocking I/O is in use, and <span class="hparameter">timeout</span>
microseconds pass, the function will abort
with an error. By default, there’s no timeout. You can specify that you
want no timeout by specifying -1.</p>
<section id="_CPPv4NK12BNetEndpoint6SocketEv">
</section>
<h3>
Socket()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">int</span><span class="w"> </span><span class="sig-prename descclassname"><span class="n">BNetEndpoint</span><span class="p">::</span></span><span class="n">Socket</span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k">const</span></pre><p>Returns the actual socket used by the <span class="hclass">BNetEndpoint</span> for data
communications.</p>
</section>
<section id="operators">
<h2>Operators<a class="headerlink" href="#operators" title="Permalink to this heading">¶</a></h2>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">BNetEndpoint</span><span class="w"> </span><span class="p">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="sig-paren">(</span><span class="k">const</span><span class="w"> </span><span class="n">BNetEndpoint</span><span class="w"> </span><span class="p">&amp;</span><span class="n sig-param">from</span><span class="sig-paren">)</span></pre><p>Copies the <span class="hclass">BNetEndpoint</span> specified by
<span class="hparameter">from</span> into the left-side object,
thereby duplicating that object. If <span class="hparameter">from</span> is connected, the left-side
object will duplicate and open the same connection.</p>
</section>
</section>


        <div class="clearer"></div>
      </div>
          </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="net-debug.html">BNetDebug</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="network-sockets.html">Network Sockets</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Haiku, Inc..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>