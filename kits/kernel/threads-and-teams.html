
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Threads And Teams &#8212; The Haiku Book  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/code.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Time Information" href="time.html" />
    <link rel="prev" title="System Information" href="system-info.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>API Documentation</span></a></h1>
        <h2 class="heading"><span>Threads And Teams</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="system-info.html">System Information</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="time.html">Time Information</a>&#160;&#160;»
        </p>

      </div>
        
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Threads And Teams</a><ul>
<li><a class="reference internal" href="#thread-and-team-functions">Thread and Team Functions</a></li>
<li><a class="reference internal" href="#thread-and-team-structures-and-types">Thread and Team Structures and Types</a></li>
<li><a class="reference internal" href="#thread-and-team-constants">Thread and Team Constants</a></li>
</ul>
</li>
</ul>

  </div>

        </div>
      </div>
          <div class="bodywrapper">
      <div class="content" role="main">
        
  <section id="threads-and-teams">
<h1>Threads And Teams<a class="headerlink" href="#threads-and-teams" title="Permalink to this heading">¶</a></h1>
<section id="thread-and-team-functions">
<h2>Thread and Team Functions<a class="headerlink" href="#thread-and-team-functions" title="Permalink to this heading">¶</a></h2>
<h3>
</h3><p>Declared in: kernel/scheduler.h</p>
<pre style="background: #f3f3f3; line-height: 2em">bigtime_t Threads And Teams::estimate_max_scheduling_latency(thread_id thread = -1)</pre><p>Returns the scheduling latency, in microseconds, of the specified thread.
Specify a thread_id of -1 to return the scheduling latency of the current
thread.</p>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">void Threads And Teams::exit_thread(status_t return_value)</pre><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::kill_thread(thread_id thread)</pre><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::kill_team(team_id team)</pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">status_t</span> <span class="n">on_exit_thread</span><span class="p">(</span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>These functions command one or more threads to halt execution:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>exit_thread()</p></td>
<td><p>Tells the calling thread to exit with a return value as given by the argument. Declaring the return value is only useful if some other thread is sitting in a <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">for()</span></code> call on this thread. exit_thread() sends a signal to the thread (after caching the return value in a known place).</p></td>
</tr>
<tr class="row-odd"><td><p>kill_thread()</p></td>
<td><p>Kills the thread given by the argument. The value that the thread will return to <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">for()</span></code> is undefined and can’t be relied upon. kill_thread() is the same as sending a SIGKILLTHR signal to the thread.</p></td>
</tr>
<tr class="row-even"><td><p>kill_team()</p></td>
<td><p>Kills all the threads within the given team. Again, the threads’ return values are random. kill_team() is the same as sending a SIGKILL signal to any thread in the team. Each of the threads in the team is then handed a SIGKILLTHR signal.</p></td>
</tr>
<tr class="row-odd"><td><p>on_exit_thread()</p></td>
<td><p>Sets up the specified callback to be executed when the calling thread exits. The callback will receive the pointer data as an input argument.</p></td>
</tr>
</tbody>
</table>
<p>Exiting a thread is a fairly safe thing to do—since a thread can
only exit itself, it’s assumed that the thread knows what it’s doing.
Killing some other thread or an entire team is a bit more drastic since
the death certificate(s) will be delivered at an indeterminate time. In
addition, killing a thread can leak memory since resources that were
allocated by the thread may not be freed. Killing an entire team, on the
other hand, won’t leak since the system reclaims all resources when the
team dies.
Keep in mind that threads die automatically (and their resources are
reclaimed) if they’re allowed to exit naturally. You should only need to
kill a thread if something has gone screwy.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The thread or team was successfully killed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_ID</span></code>.</p></td>
<td><p>Invalid thread value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_TEAM_ID</span></code>.</p></td>
<td><p>Invalid team value.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_NO_MEMORY</span></code>.</p></td>
<td><p>Returned by on_exit_thread() if there’s no memory to construct the internal callback record.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">thread_id Threads And Teams::find_thread(const char* name)</pre><p>Finds and returns the thread with the given <span class="hparameter">name</span>. A
<span class="hparameter">name</span> argument of <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">NULL</span></code>
returns the calling thread.
A thread’s name is assigned when the thread is spawned. The name can be
changed thereafter through the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>
function. Keep in mind
that thread names needn’t be unique: If two (or more) threads boast the
same name, a find_thread() call on that name returns the first so-named
thread that it finds. There’s no way to iterate through identically-named
threads.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_NAME_NOT_FOUND</span></code>.</p></td>
<td><p><span class="hparameter">name</span> doesn’t identify a valid thread.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::get_team_info(team_id team, team_info* info)</pre><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::get_next_team_info(int32* cookie, team_info* info)</pre><p>The functions copy, into the <span class="hparameter">info</span>
argument, the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">info()</span></code> structure for a
particular team. The get_team_info() function retrieves information for
the team identified by <span class="hparameter">team</span>. For information about the kernel, use
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_SYSTEM_TEAM</span></code> as the team argument.
The get_next_team_info() version lets you step through the list of all
teams. The <span class="hparameter">cookie</span> argument is a placemark; you set it to 0 on your first
call, and let the function do the rest. The function returns <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_VALUE</span></code>
when there are no more areas to visit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Get</span> <span class="n">the</span> <span class="n">team_info</span> <span class="k">for</span> <span class="n">every</span> <span class="n">team</span><span class="o">.</span> <span class="o">*/</span>
<span class="n">team_info</span> <span class="n">info</span><span class="p">;</span>
<span class="n">int32</span> <span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">get_next_team_info</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="n">B_OK</span><span class="p">)</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>See
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">info()</span></code>
for a description of that structure.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The desired team information was found.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_TEAM_ID</span></code>.</p></td>
<td><p><span class="hparameter">team</span> doesn’t identify an existing team, or there are no more areas to visit.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::get_thread_info(thread_id thread, thread_info* info)</pre><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::get_next_thread_info(team_id team, int32* cookie, thread_info* info)</pre><p>These functions copy, into the <span class="hparameter">info</span>
argument, the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">info()</span></code>
structure for a particular thread:
The get_thread_info() function gets the
information for the thread identified by <span class="hparameter">thread</span>.
The get_next_thread_info() function lets you step through the list of a
team’s threads through iterated calls. The <span class="hparameter">team</span> argument identifies the
team you want to look at; a <span class="hparameter">team</span> value of 0 means the team of the calling
thread. The <span class="hparameter">cookie</span> argument is a placemark; you set it to 0 on your first
call, and let the function do the rest. The function returns <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_VALUE</span></code>
when there are no more threads to visit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Get</span> <span class="n">the</span> <span class="n">thread_info</span> <span class="k">for</span> <span class="n">every</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">team</span><span class="o">.</span> <span class="o">*/</span>
<span class="n">thread_info</span> <span class="n">info</span><span class="p">;</span>
<span class="n">int32</span> <span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">get_next_thread_info</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="n">B_OK</span><span class="p">)</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>The value of the priority field describes the thread’s “urgency”; the
higher the value, the more urgent the thread. The more urgent the thread,
the more attention it gets from the CPU. Expected priority values fall
between 0 and 120.
See “<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ThreadPriorities()</span></code>”
for the full story.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The thread was found; <span class="hparameter">info</span> contains valid information.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_VALUE</span></code>.</p></td>
<td><p><span class="hparameter">thread</span> doesn’t identify an existing thread, <span class="hparameter">team</span> doesn’t identify an existing team, or there are no more threads to visit.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::rename_thread(thread_id thread, const char* name)</pre><p>Changes the name of the given thread to <span class="hparameter">name</span>. The name can be no longer
than <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OS_NAME_LENGTH</span></code> (32 characters).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The thread was successfully named.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_ID</span></code>.</p></td>
<td><p><span class="hparameter">thread</span> argument isn’t a valid thread_id number.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::resume_thread(thread_id thread)</pre><p>Tells a new or suspended thread to begin executing instructions. If the
thread has just been spawned, it enters and executes the thread function
declared in <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>.
If the thread was previously suspended(through
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>),
it continues from where it was suspended.
You can’t use this function to wake up a sleeping thread, or to unblock a
thread that’s waiting to acquire a semaphore or waiting in a
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
call. However, you can unblock any of these threads by
suspending and then resuming. Blocked threads that are resumed return
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_INTERRUPTED</span></code>.
resume_thread() is the same as sending a
SIGCONT signal to the thread.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The thread was successfully resumed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_ID</span></code>.</p></td>
<td><p><span class="hparameter">thread</span> argument isn’t a valid thread_id number.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_STATE</span></code>.</p></td>
<td><p>The thread isn’t suspended.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">int32 Threads And Teams::receive_data(thread_id sender, void* buffer, size_t buffer_size)</pre><p>Retrieves a message from the thread’s message cache. The message will
have been placed there through a previous
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
function call. If the cache is empty, receive_data()
blocks until one shows up—it never returns empty-handed.
The thread_id of the thread that called
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
is returned by reference in the sender argument. Note that there’s no guarantee that the
sender will still be alive by the time you get its ID. Also, the value of
sender going into the function is ignored—you can’t ask for a
message from a particular sender.
The
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
function copies two pieces of data into a thread’s
message cache:</p>
<ul class="simple">
<li><p>A single four-byte code that’s delivered as receive_data()’s return value,</p></li>
<li><p>and an arbitrarily long data buffer that’s copied into receive_data()’s buffer argument (you must allocate and free buffer yourself). The <span class="hparameter">buffer_size</span> argument tells the function how many bytes of data to copy. If you don’t need the data buffer—if the code value returned directly by the function is sufficient—you set <span class="hparameter">buffer</span> to <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">NULL</span></code> and <span class="hparameter">buffer_size</span> to 0.</p></li>
</ul>
<p>Unfortunately, there’s no way to tell how much data is in the cache
before you call receive_data():</p>
<ul class="simple">
<li><p>If there’s more data than buffer can accommodate, the unaccommodated portion is discarded—a second receive_data() call will not read the rest of the message.</p></li>
<li><p>Conversely, if receive_data() asks for more data than was sent, the function returns with the excess portion of buffer unmodified—receive_data() doesn’t wait for another <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code> call to provide more data with which to fill up the buffer.</p></li>
</ul>
<p>Each receive_data() corresponds to exactly one
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>.
Lacking a previous invocation of its mate, receive_data() will block until
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
is called. If you don’t want to block, you should call
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
before calling receive_data() (and proceed to
receive_data()
only if <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
returns <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">true</span></code>).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>If successful</p></td>
<td><p>Returns the message’s four-byte code.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_INTERRUPTED</span></code>.</p></td>
<td><p>A blocked receive_data() call was interrupted by a signal.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::send_data(thread_id sender, void* buffer, size_t buffer_size)</pre><p>send_data() copies a message into thread’s message cache. The target
thread retrieves the message (and empties the cache) by calling
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>.
There are two parts to the message:</p>
<ul class="simple">
<li><p>A single four-byte code passed as an argument to send_data() and returned directly by <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>.</p></li>
<li><p>A <span class="hparameter">buffer</span> of data that’s <span class="hparameter">buffer_size</span> bytes long (<span class="hparameter">buffer</span> can be <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">NULL</span></code>, in which case <span class="hparameter">buffer_size</span> should be 0). The data is copied into the target thread’s cache, and then copied into <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>’s <span class="hparameter">buffer</span> (which must be allocated). The calling threads retain responsibility for freeing their buffers.</p></li>
</ul>
<p>In addition to returning the <span class="hparameter">code</span> directly, and copying the message data
into its <span class="hparameter">buffer</span> argument,
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
sets <span class="hparameter">sender</span> to the id of the thread that sent the message.
send_data() blocks if there’s an unread message in the target thread’s
cache; otherwise it returns immediately (i.e. it doesn’t wait for the
target to call <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>.
Analogously, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
blocks until there’s a message to retrieve.
In the following example, the main thread spawns a thread, sends it a
message, and then tells the thread to run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">thread_id</span> <span class="n">other_thread</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
   <span class="n">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
   <span class="n">other_thread</span> <span class="o">=</span> <span class="n">spawn_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
   <span class="n">send_data</span><span class="p">(</span><span class="n">other_thread</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
   <span class="n">resume_thread</span><span class="p">(</span><span class="n">other_thread</span><span class="p">);</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To retrieve the message, the target thread calls
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span> <span class="n">thread_func</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">thread_id</span> <span class="n">sender</span><span class="p">;</span>
   <span class="n">int32</span> <span class="n">code</span><span class="p">;</span>
   <span class="n">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
   <span class="n">code</span> <span class="o">=</span> <span class="n">receive_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sender</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Keep in mind that the message data is copied into the buffer; you must
allocate adequate storage for the data. If the buffer isn’t big enough to
accommodate all the datain the message, the left-over portion is thrown
away. Note, however, that there isn’t any way for a thread to determine
how much data has been copied into its message cache.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The data was successfuly sent.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_ID</span></code>.</p></td>
<td><p><span class="hparameter">thread</span> doesn’t identify a valid thread.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_NO_MEMORY</span></code>.</p></td>
<td><p>The target couldn’t allocate enough memory for its copy of buffer.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_INTERRUPTED</span></code>.</p></td>
<td><p>The function blocked, but a signal unblocked it.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">bool Threads And Teams::has_data(thread_id thread)</pre><p>has_data() returns <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">true</span></code> if
<span class="hparameter">thread</span> has a message in its message cache.
Ostensibly, you use this function before calling
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code> or
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
to avoid blocking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if (!has_data(target_thread))
   err = send_data(target_thread, ...);
/* or */
if (has_data(find_thread(NULL))
   code = receive_data(...);
</pre></div>
</div>
<p>This works for
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>,
but notice that there’s a race condition between the
has_data() and
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code>
calls. Another thread could send a message to the target in the interim.</p>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::set_thread_priority(thread_id thread, int32 new_priority)</pre><pre style="background: #f3f3f3; line-height: 2em">int32 Threads And Teams::suggest_thread_priority(uint32 what = B_DEFAULT_MEDIA_PRIORITY, int32 period = 0, bigtime_t jitter = 0, bigtime_t length = 0)</pre><p>Declared in:  kernel/scheduler.h
set_thread_priority() resets the given thread’s priority to <span class="hparameter">new_priority</span>.
The priority is expected to be between 0 and 120.
See “Thread Priorities”
for a description of the priority scheme, and
“Thread Priority Values”
for a list of pre-defined priority constants.
suggest_thread_priority() takes information about a thread and returns a
suggested priority that you can pass to set_thread_priority() (or, more
likely, to
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>).
The <span class="hparameter">what</span> value is a bit mask that indicates the type of activities the
thread will be used for. The possible values are listed in
Suggested Thread Priorities.
<span class="hparameter">period</span> is the number of times per second the thread needs to be run
(specify 0 if it needs to run continuously). <span class="hparameter">jitter</span> is an estimate, in
microseconds, of how much the period can vary as long as the average
stays at <span class="hparameter">period</span> times per second.
<span class="hparameter">length</span> is an approximation of the amount of time, in microseconds, the
thread will typically run per invocation (i.e., the amount of time that
will pass between the moment it receives a message, through processing
it, until it’s again waiting for another message).
For example, if you’re spawning a thread to handle video refresh for a
computer game, and you want the display to update 30 times per second,
you might use code similar to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span> <span class="n">priority</span><span class="p">;</span>
<span class="n">priority</span> <span class="o">=</span> <span class="n">suggest_thread_priority</span><span class="p">(</span><span class="n">B_LIVE_3D_RENDERING</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
<span class="n">th</span> <span class="o">=</span> <span class="n">spawn_thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;render_thread&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">NULL</span><span class="p">)</span>
</pre></div>
</div>
<p>This spawns the rendering thread with a priority appropriate for a thread
for live 3D rendering which wants to be run 30 times per second, with a
variation of only 1000 microseconds. Each invocation of the thread’s code
is estimated to take 150 microseconds. Obviously the jitter and length
values would have to be tuned to the particular application.
set_thread_priority() returns…</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Positive integers.</p></td>
<td><p>If the function is successful, the previous priority is returned.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_ID</span></code>.</p></td>
<td><p><span class="hparameter">thread</span> doesn’t identify a valid thread.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::snooze(bigtime_t microseconds, int32 new_priority)</pre><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::snooze_until(bigtime_t microseconds, int timebase)</pre><p>snooze() blocks the calling thread for
the given number of <span class="hparameter">microseconds</span>.
snooze_until() blocks until an absolute time measured in the given
<span class="hparameter">timebase</span>. Currently, the only allowed value for <span class="hparameter">timebase</span> is
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_SYSTEM_TIMEBASE</span></code>, which measures time against the system clock (as
reported by <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">time()</span></code>).</p>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">thread_id Threads And Teams::spawn_thread(thread_func func, const char* name, int32 priority, void* data)</pre><p>Creates a new thread and returns its thread_id identifier (a positive
integer). The arguments are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>func</p></td>
<td><p>Is a pointer to a thread function. This is the function that the thread will execute when it’s told to run. See “The Thread Function” for details.</p></td>
</tr>
<tr class="row-odd"><td><p>name</p></td>
<td><p>Is the name that you wish to give the thread. It can be, at most, <code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OS_NAME_LENGTH</span></code> (32) characters long.</p></td>
</tr>
<tr class="row-even"><td><p>priority</p></td>
<td><p>Is the CPU priority level of the thread. This value should be between 0 and 120; he higher the priority, the more attention the thread gets. See Thread Priorities for a description of the priorities, and Thread Priority Values for a list of priority constants.</p></td>
</tr>
<tr class="row-odd"><td><p>data</p></td>
<td><p>Is forwarded as the argument to the thread function.</p></td>
</tr>
</tbody>
</table>
<p>A newly spawned thread is in a suspended state
(<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_THREAD_SUSPENDED</span></code>). To
tell the thread to run, you pass its thread_id to the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>
function. The thread will continue to run until the thread function
exits, or until the thread is explicitly killed (through a signal or a
call to <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>,
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>, or
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">team()</span></code>).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_NO_MORE_THREADS</span></code>.</p></td>
<td><p>All thread_id numbers are currently in use.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_NO_MEMORY</span></code>.</p></td>
<td><p>Not enough memory to allocate the resources for another thread.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::suspend_thread(thread_id thread)</pre><p>Halts the execution of the given thread, but doesn’t kill the thread
entirely. The thread remains suspended (suspend_thread() blocks) until
it’s told to run through the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>
function. Nothing prevents you from suspending your own thread, i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">suspend_thread</span><span class="p">(</span><span class="n">find_thread</span><span class="p">(</span><span class="n">NULL</span><span class="p">));</span>
</pre></div>
</div>
<p>Of course, this is only smart if you have some other thread that will
resume you later.
You can suspend any thread, regardless of its current state. But be
careful: If the thread is blocked on a semaphore (for example), the
subsequent
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>
call will “hop over” the semaphore acquisition.
Suspensions don’t nest. A single
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code> unsuspends a thread
regardless of the number of suspend_thread() calls it has received.
suspend_thread() is the same as sending a
SIGSTOP signal to the thread.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The thread is now suspended.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_ID</span></code>.</p></td>
<td><p>thread isn’t a valid thread_id number.</p></td>
</tr>
</tbody>
</table>
<h3>
</h3><pre style="background: #f3f3f3; line-height: 2em">status_t Threads And Teams::wait_for_thread(thread_id thread, status_t* exit_value)</pre><p>This function causes the calling thread to wait until thread (the “target
thread”) has died. If thread is suspended (or freshly spawned),
wait_for_thread() will resume it.
When the target thread is dead, the value that was returned by its thread
function (or imposed by
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>)
is returned in <span class="hparameter">exit_value</span>. If the
target thread was killed (by
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code> or
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">team()</span></code>),
or if the thread function doesn’t return a value, the value returned in
<span class="hparameter">exit_value</span> will be unreliable.
You must pass a valid pointer as the second argument to
wait_for_thread(). You mustn’t pass
<code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">NULL</span></code> even if you’re not interested in
the return value.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Return Code</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OK</span></code>.</p></td>
<td><p>The target is now dead.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_BAD_THREAD_ID</span></code>.</p></td>
<td><p><span class="hparameter">thread</span> isn’t a valid thread_id number.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_INTERRUPTED</span></code>.</p></td>
<td><p>The target was killed by a signal. This includes <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">team()</span></code>, and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="thread-and-team-structures-and-types">
<h2>Thread and Team Structures and Types<a class="headerlink" href="#thread-and-team-structures-and-types" title="Permalink to this heading">¶</a></h2>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">int32</span> <span class="n">team_id</span> <span class="p">;</span>
<span class="n">typedef</span> <span class="n">int32</span> <span class="n">thread_id</span> <span class="p">;</span>
</pre></div>
</div>
<p>These id numbers uniquely identify teams and threads, respecitvely.</p>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">team_id</span>   <span class="n">team</span><span class="p">;</span>
    <span class="n">int32</span>     <span class="n">thread_count</span><span class="p">;</span>
    <span class="n">int32</span>     <span class="n">image_count</span><span class="p">;</span>
    <span class="n">int32</span>     <span class="n">area_count</span><span class="p">;</span>
    <span class="n">thread_id</span> <span class="n">debugger_nub_thread</span><span class="p">;</span>
    <span class="n">port_id</span>   <span class="n">debugger_nub_port</span><span class="p">;</span>
    <span class="n">int32</span>     <span class="n">argc</span><span class="p">;</span>
    <span class="n">char</span>      <span class="n">args</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="n">uid_t</span>     <span class="n">uid</span><span class="p">;</span>
    <span class="n">gid_t</span>     <span class="n">gid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">team_info</span><span class="p">;</span>
</pre></div>
</div>
<p>The team_info structure returns information about a team. To retrieve one
of these structures, use
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">team()</span></code> or
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">next()</span></code>.
The first field is obvious; the next three reasonably so: They give the
number of threads that have been spawned, images that have been loaded,
and areas that have been created or cloned within this team.
The debugger fields are used by the, uhm, the…debugger?
The argc field is the number of command line arguments that were used to
launch the team; args is a copy of the first 64 characters from the
command line invocation. If this team is an application that was launched
through the user interface (by double-clicking, or by accepting a dropped
icon), then argc is 1 and args is the name of the application’s
executable file.
uid and gid identify the user
and group that “owns” the team. You can use
these values to play permission games.</p>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">int32</span> <span class="p">(</span><span class="o">*</span><span class="n">thread_func</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>thread_func is the prototype for a thread’s thread function. You specify
a thread function by passing a thread_func as the first argument to
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>;
the last argument to
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>
is forwarded as the thread function’s data argument. When the thread function exits, the
spawned thread is automatically killed. To retrieve a thread_func’s
return value, some other thread must be waiting in a
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">for()</span></code>
call.
Note that
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>
doesn’t copy the data that data points to. It
simply passes the pointer through literally. Never pass a pointer that’s
allocated locally (on the stack).</p>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">thread_id</span>    <span class="n">thread</span><span class="p">;</span>
    <span class="n">team_id</span>      <span class="n">team</span><span class="p">;</span>
    <span class="n">char</span>         <span class="n">name</span><span class="p">[</span><span class="n">B_OS_NAME_LENGTH</span><span class="p">];</span>
    <span class="n">thread_state</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">sem_id</span>       <span class="n">sem</span><span class="p">;</span>
    <span class="n">int32</span>        <span class="n">priority</span><span class="p">;</span>
    <span class="n">bigtime_t</span>    <span class="n">user_time</span><span class="p">;</span>
    <span class="n">bigtime_t</span>    <span class="n">kernel_time</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span>       <span class="n">stack_base</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span>       <span class="n">stack_end</span><span class="p">;</span>
<span class="p">}</span> <span class="n">thread_info</span>
</pre></div>
</div>
<p>The thread_info structure contains information about a thread. To
retrieve one of these structure, use
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code> or
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">next()</span></code>.
The thread, team,
and name fields contain the indicated information.
state describes what the thread is currently doing (see
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">state()</span></code> for
the list of states). If the thread is waiting to acquire a semaphore, sem
is that semaphore.
priority is a value that indicates the level of attention the thread gets
(see Thread Priority).
user_time and kernel_time
are the amounts of time, in microseconds, the
thread has spent executing user code and the amount of time the kernel
has run on the thread’s behalf, respectively.
stack_base and stack_end
are pointers to the first byte and last bytes in
the thread’s execution stack. Currently, the stack size is fixed at
around 256k.</p>
<div class="warning admonition">
<p class="admonition-title">Warning</p>
<p>The two stack pointers are currently inverted such that stack_base is
less than stack_end.
(In a stack-grows-down world, the base should be
greater than the end.)</p>
</div>
</section>
<section id="thread-and-team-constants">
<h2>Thread and Team Constants<a class="headerlink" href="#thread-and-team-constants" title="Permalink to this heading">¶</a></h2>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define B_SYSTEM_TEAM ...</span>
</pre></div>
</div>
<p>Use this constant as the first argument to
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">team()</span></code>
to get team information about the kernel).</p>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define B_SYSTEM_TIMEBASE ...</span>
</pre></div>
</div>
<p>The system timebase constant is used as a basis for time measurement in
the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">until()</span></code>
function. (Currently, it’s the only timebase available.)</p>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">be_task_flags</span> <span class="p">{</span>
    <span class="n">B_DEFAULT_MEDIA_PRIORITY</span><span class="p">,</span>
    <span class="n">B_OFFLINE_PROCESSING</span><span class="p">,</span>
    <span class="n">B_STATUS_RENDERING</span><span class="p">,</span>
    <span class="n">B_USER_INPUT_HANDLING</span><span class="p">,</span>
    <span class="n">B_LIVE_VIDEO_MANIPULATION</span><span class="p">,</span>
    <span class="n">B_VIDEO_PLAYBACK</span><span class="p">,</span>
    <span class="n">B_VIDEO_RECORDING</span><span class="p">,</span>
    <span class="n">B_LIVE_AUDIO_MANIPULATION</span><span class="p">,</span>
    <span class="n">B_AUDIO_PLAYBACK</span><span class="p">,</span>
    <span class="n">B_AUDIO_RECORDING</span><span class="p">,</span>
    <span class="n">B_LIVE_3D_RENDERING</span><span class="p">,</span>
    <span class="n">B_NUMBER_CRUNCHING</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Declared in: kernel/scheduler.h</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_DEFAULT_MEDIA_PRIORITY</span></code>.</p></td>
<td><p>The thread isn’t doing anything specialized.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_OFFLINE_PROCESSING</span></code>.</p></td>
<td><p>The thread is doing non-real-time computations.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_STATUS_RENDERING</span></code>.</p></td>
<td><p>The thread is rendering a status or preview display.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_USER_INPUT_HANDLING</span></code>.</p></td>
<td><p>The thread is handling user input.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_LIVE_VIDEO_MANIPULATION</span></code>.</p></td>
<td><p>The thread is processing live video (filtering, compression, decompression, etc.).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_VIDEO_PLAYBACK</span></code>.</p></td>
<td><p>The thread is playing back video from a hardware device.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_VIDEO_RECORDING</span></code>.</p></td>
<td><p>The thread is recording video from a hardware device.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_LIVE_AUDIO_MANIPULATION</span></code>.</p></td>
<td><p>The thread is doing real-time manipulation of live audio data (filtering, compression, decompression, etc.).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_AUDIO_PLAYBACK</span></code>.</p></td>
<td><p>The thread is playing back audio from a hardware device.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_AUDIO_RECORDING</span></code>.</p></td>
<td><p>The thread is recording audio from a hardware device.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_LIVE_3D_RENDERING</span></code>.</p></td>
<td><p>The thread is performing live 3D rendering.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_NUMBER_CRUNCHING</span></code>.</p></td>
<td><p>The thread is doing data processing.</p></td>
</tr>
</tbody>
</table>
<p>These constants describe what the thread is designed to do. You use these
constants when asking for a suggested priority (see
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>).</p>
<div class="warning admonition">
<p class="admonition-title">Warning</p>
<p>These constants may not be used as actual thread priority
values—do not pass one of these values as the priority argument to
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>.</p>
</div>
<h3>
</h3><p>Time-Sharing PriorityValueB_LOW_PRIORITY5B_NORMAL_PRIORITY10B_DISPLAY_PRIORITY15B_URGENT_DISPLAY_PRIORITY20
Real-Time PriorityValueB_REAL_TIME_DISPLAY_PRIORITY100B_URGENT_PRIORITY110B_REAL_TIME_PRIORITY120
The thread priority values are used to set the “urgency” of a thread.
Although you can reset a thread’s priority through
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>,
the priority is initially—and almost always permanently—set
in <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>.</p>
<h3>
</h3><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="n">thread_state</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_THREAD_RUNNING</span></code>.</p></td>
<td><p>The thread is currently receiving attention from a CPU.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_THREAD_READY</span></code>.</p></td>
<td><p>The thread is waiting for its turn to receive attention.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_THREAD_SUSPENDED</span></code>.</p></td>
<td><p>The thread has been suspended or is freshly-spawned and is waiting to start.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_THREAD_WAITING</span></code>.</p></td>
<td><p>The thread is waiting to acquire a semaphore. The sem field of the thread’s <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">info()</span></code> structure will tell you which semaphore.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_THREAD_RECEIVING</span></code>.</p></td>
<td><p>The thread is sitting in a <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">data()</span></code> function call.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">B_THREAD_ASLEEP</span></code>.</p></td>
<td><p>The thread is sitting in a <span class="xref std std-ref">snooze()</span> call.</p></td>
</tr>
</tbody>
</table>
<p>A thread’s state tells you what the thread is currently doing. To get the
state, look in the state field of the
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">info()</span></code>
structure (retrieved through
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">thread()</span></code>).</p>
</section>
</section>


        <div class="clearer"></div>
      </div>
          </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="system-info.html">System Information</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="time.html">Time Information</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Haiku, Inc..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>