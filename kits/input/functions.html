
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Functions &#8212; The Haiku Book  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/code.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="BInputDevice" href="input-device.html" />
    <link rel="prev" title="BWindowScreen" href="../game/window-screen.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>API Documentation</span></a></h1>
        <h2 class="heading"><span>Functions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../game/window-screen.html">BWindowScreen</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="input-device.html">BInputDevice</a>&#160;&#160;»
        </p>

      </div>
        
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Functions</a><ul>
<li><a class="reference internal" href="#mouse-functions">Mouse Functions</a><ul>
<li><a class="reference internal" href="#_CPPv415set_click_speed9bigtime_t">set_click_speed</a></li>
<li><a class="reference internal" href="#_CPPv415get_click_speedP9bigtime_t">get_click_speed</a></li>
<li><a class="reference internal" href="#_CPPv413set_mouse_map9mouse_map">set_mouse_map</a></li>
<li><a class="reference internal" href="#_CPPv413get_mouse_mapP9mouse_map">get_mouse_map</a></li>
<li><a class="reference internal" href="#_CPPv414set_mouse_type10numButtons">set_mouse_type</a></li>
<li><a class="reference internal" href="#_CPPv414get_mouse_typeP5int32">get_mouse_type</a></li>
<li><a class="reference internal" href="#_CPPv415set_mouse_speed5int32">set_mouse_speed</a></li>
<li><a class="reference internal" href="#_CPPv415get_mouse_speedP5int32">get_mouse_speed</a></li>
<li><a class="reference internal" href="#_CPPv422set_mouse_acceleration5int32">set_mouse_acceleration</a></li>
<li><a class="reference internal" href="#_CPPv422get_mouse_accelerationP5int32">get_mouse_acceleration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#keyboard-functions">Keyboard Functions</a><ul>
<li><a class="reference internal" href="#_CPPv412get_key_infoP8key_info">get_key_info</a></li>
<li><a class="reference internal" href="#_CPPv411get_key_mapPP7key_mapPPc">get_key_map</a></li>
<li><a class="reference internal" href="#_CPPv415get_keyboard_idP6uint16">get_keyboard_id</a></li>
<li><a class="reference internal" href="#_CPPv49modifiersv">modifiers</a></li>
<li><a class="reference internal" href="#_CPPv419set_key_repeat_rate5int32">set_key_repeat_rate</a></li>
<li><a class="reference internal" href="#_CPPv419get_key_repeat_rateP5int32">get_key_repeat_rate</a></li>
<li><a class="reference internal" href="#_CPPv420set_key_repeat_delay9bigtime_t">set_key_repeat_delay</a></li>
<li><a class="reference internal" href="#_CPPv420get_key_repeat_delayP9bigtime_t">get_key_repeat_delay</a></li>
<li><a class="reference internal" href="#_CPPv418set_keyboard_locks6uint32">set_keyboard_locks</a></li>
<li><a class="reference internal" href="#_CPPv416set_modifier_key6uint326uint32">set_modifier_key</a></li>
<li><a class="reference internal" href="#instantiate-input-device">instantiate_input_device()</a></li>
<li><a class="reference internal" href="#instantiate-input-filter">instantiate_input_filter()</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>

        </div>
      </div>
          <div class="bodywrapper">
      <div class="content" role="main">
        
  <section id="functions">
<h1 id="CPPv49Functions">Functions<a class="headerlink" href="#functions" title="Permalink to this heading">¶</a></h1>
<table class="colwidths-auto docutils align-left">
<tbody>
<tr class="row-odd"><td><p>Declared In:</p></td>
<td><p>interface/InterfaceDefs.h</p></td>
</tr>
<tr class="row-even"><td><p>Library:</p></td>
<td><p>libbe.so</p></td>
</tr>
</tbody>
</table>
<p>This section describes the global mouse and keyboard functions.</p>
<section id="mouse-functions">
<h2>Mouse Functions<a class="headerlink" href="#mouse-functions" title="Permalink to this heading">¶</a></h2>
<section id="_CPPv415set_click_speed9bigtime_t">
</section>
<section id="_CPPv415get_click_speedP9bigtime_t">
</section>
<h3>
set_click_speed(), get_click_speed()</h3><p>Declared in:  interface/InterfaceDefs.h</p>
<pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">set_click_speed</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">interval</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_click_speed</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">interval</span><span class="sig-paren">)</span></pre><p>These functions set and report the timing for multiple-clicks. For
successive mouse-down events to count as a multiple-click, they must occur
within the interval set by set_click_speed() and provided by
get_click_speed(). The <span class="hparameter">interval</span> is measured in microseconds; it’s
usually set by the user in the Mouse preferences application. The smallest
possible interval is 100,000 microseconds (0.1 second).</p>
<p>If successful, these functions return <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code>; if
unsuccessful, they return an error code, which may be just
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_ERROR</span></code>.</p>
<section id="_CPPv413set_mouse_map9mouse_map">
</section>
<section id="_CPPv413get_mouse_mapP9mouse_map">
</section>
<section id="_CPPv414set_mouse_type10numButtons">
</section>
<section id="_CPPv414get_mouse_typeP5int32">
</section>
<section id="_CPPv415set_mouse_speed5int32">
</section>
<section id="_CPPv415get_mouse_speedP5int32">
</section>
<section id="_CPPv422set_mouse_acceleration5int32">
</section>
<section id="_CPPv422get_mouse_accelerationP5int32">
</section>
<h3>
set_mouse_map(), get_mouse_map(), set_mouse_type(), get_mouse_type(), set_mouse_speed(), get_mouse_speed(), set_mouse_acceleration(), get_mouse_acceleration()</h3><p>Declared in:  interface/InterfaceDefs.h</p>
<pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">set_mouse_map</span><span class="sig-paren">(</span><span class="n">mouse_map</span><span class="w"> </span><span class="n sig-param">map</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_mouse_map</span><span class="sig-paren">(</span><span class="n">mouse_map</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">map</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">set_mouse_type</span><span class="sig-paren">(</span><span class="n">numButtons</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_mouse_type</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">numButtons</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">set_mouse_speed</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="n sig-param">speed</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_mouse_speed</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">speed</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">set_mouse_acceleration</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="n sig-param">acceleration</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_mouse_acceleration</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">acceleration</span><span class="sig-paren">)</span></pre><p>These functions configure the mouse and supply information about the
current configuration. The configuration should usually be left to the user
and the Mouse preferences application.</p>
<p>set_mouse_map() maps the buttons of the mouse to their roles in the user
interface, and get_mouse_map() writes the current map into the variable
referred to by <span class="hparameter">map</span>. The <span class="htype">mouse_map</span> structure has a field
for each button on a three-button mouse:</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32left</p></td>
<td><p>The button on the left of the mouse</p></td>
</tr>
<tr class="row-odd"><td><p>uint32right</p></td>
<td><p>The button on the right of the mouse</p></td>
</tr>
<tr class="row-even"><td><p>uint32middle</p></td>
<td><p>The button in the middle, between the other two buttons</p></td>
</tr>
</tbody>
</table>
<p>Each field is set to one of the following constants:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_PRIMARY_MOUSE_BUTTON</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SECONDARY_MOUSE_BUTTON</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_TERTIARY_MOUSE_BUTTON</span></code></p></li>
</ul>
<p>The same role can be assigned to more than one physical button. If all
three buttons are set to <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_PRIMARY_MOUSE_BUTTON</span></code>, they all
function as the primary button; if two of them are set to
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SECONDARY_MOUSE_BUTTON</span></code>, they both function as the
secondary button; and so on.</p>
<p>set_mouse_type() informs the system of how many buttons the mouse actually
has. If it has two buttons, only the left and right fields of the
<span class="htype">mouse_map</span> are operative. If it has just one button, only the left
field is operative. set_mouse_type() writes the current number of buttons
into the variable referred to by <span class="hparameter">numButtons</span>.</p>
<p>set_mouse_speed() sets the speed of the mouse—the rate at which the cursor
image moves on-screen relative to the actual speed at which the user moves
the mouse on its pad. A speed value of 0 is the slowest movement rate. The
maximum rate is 20, though even 10 is too fast for most users.
get_mouse_speed() writes the current speed into the variable referred to by
<span class="hparameter">speed</span>.</p>
<p>set_mouse_acceleration() sets the mouse’s acceleration—the rate at which
the cursor image gains and loses speed as the user begins and ceases moving
the mouse. An acceleration value of 0 is the slowest movement rate. The
maximum rate is 20, though even 10 is too fast for most users.
get_mouse_acceleration() writes the current acceleration into the variable
referred to by <span class="hparameter">acceleration</span>.</p>
<p>All six functions return <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code> if successful, and an
error code, typically <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_ERROR</span></code>, if not.</p>
</section>
<section id="keyboard-functions">
<h2>Keyboard Functions<a class="headerlink" href="#keyboard-functions" title="Permalink to this heading">¶</a></h2>
<section id="_CPPv412get_key_infoP8key_info">
</section>
<h3>
get_key_info()</h3><p>Declared in:  interface/InterfaceDefs.h</p>
<pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_key_info</span><span class="sig-paren">(</span><span class="n">key_info</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">keyInfo</span><span class="sig-paren">)</span></pre><p>Writes information about the state of the keyboard into the
<span class="htype">key_info</span> structure referred to by <span class="hparameter">keyInfo</span>. This function
lets you get information about the keyboard in the absence of
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_KEY_DOWN</span></code> messages. The <span class="htype">key_info</span> structure has
just two fields:</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32modifiers</p></td>
<td><p>A mask indicating which modifier keys are down and which keyboard locks
are on.</p></td>
</tr>
<tr class="row-odd"><td><p>uint8key_states[16]</p></td>
<td><p>A bit array that records the state of all the keys on the keyboard, and
all the keyboard locks. This array works identically to the “states” array
passed in a key-down message. See “<span class="xref std std-ref">Key States</span>” in the <span class="xref std std-ref">The   Keyboard</span> chapter for information on how to read information from the
array.</p></td>
</tr>
</tbody>
</table>
<p>get_key_info() returns <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code> if it was able to get the
requested information, and <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_ERROR</span></code> if the return results
are unreliable.</p>
<p>See also: <a class="reference internal" href="../interface/view.html#_CPPv4N5BView7KeyDownEPKc5int32" title="BView::KeyDown"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BView::KeyDown()</span></code></a>, <span class="xref std std-ref">modifiers()</span></p>
<section id="_CPPv411get_key_mapPP7key_mapPPc">
</section>
<h3>
get_key_map()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">void</span><span class="w"> </span><span class="n">get_key_map</span><span class="sig-paren">(</span><span class="n">key_map</span><span class="w"> </span><span class="p">*</span><span class="p">*</span><span class="n sig-param">keys</span>, <span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="p">*</span><span class="n sig-param">chars</span><span class="sig-paren">)</span></pre><p>Declared in: interface/InterfaceDefs.h</p>
<p>Provides a pointer to a copy of the system key map—the structure that
describes the role of each key on the keyboard. The pointers returned by
the function are yours; you must free() them when you’re finished with
them.</p>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>In versions of the BeOS before Release 4, the pointers used to belong to
the operating system. Now they’re yours to do with as you please. Please
update your applications as necessary to avoid leaking memory.</p>
</div>
<p>Through the Keymap preferences application, users can configure the
keyboard to their liking. The user’s preferences are stored in a file
(Key_map within the <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_USER_SETTINGS_DIRECTORY</span></code>, returned
by the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_directory()</span></code> function). When the
machine reboots, the key map is read from this file. If the file doesn’t
exist, the original map encoded in the Application Server is used.</p>
<p>The <span class="htype">key_map</span> structure contains a large number of fields, but it
can be broken down into these six parts:</p>
<ol class="arabic simple">
<li><p>A version number.</p></li>
<li><p>A series of fields that determine which keys will function as modifier
keys—such as <span class="hkey">Shift</span>, <span class="hkey">Control</span>, or <span class="hkey">Num Lock</span>.</p></li>
<li><p>A field that sets the initial state of the keyboard locks in the default
key map.</p></li>
<li><p>A series of ordered tables that assign character values to keys. Except
for a handful of modifier keys, all keys are mapped to characters, though
they may not be mapped for all modifier combinations.</p></li>
<li><p>A series of tables that locate the dead keys for diacritical marks and
determine how a combination of a dead key plus another key is mapped to a
particular character.</p></li>
<li><p>A set of masks that determine which modifier keys are required for a key
to be considered dead.</p></li>
</ol>
<p>The following sections describe the parts of the <span class="htype">key_map</span>
structure.</p>
<p class="rubric">Version</p>
<p>The first field of the key map is a version number:</p>
<table class="colwidths-auto docutils align-left">
<tbody>
<tr class="row-odd"><td><p>uint32version</p></td>
<td><p>An internal identifier for the key map.</p></td>
</tr>
</tbody>
</table>
<p>The version number doesn’t change when the user configures the keyboard,
and shouldn’t be changed programmatically either. You can ignore it.</p>
<p class="rubric">Modifiers</p>
<p>Modifier keys set states that affect other user actions on the keyboard
and mouse. Eight modifier states are defined—<span class="hkey">Shift</span>,
<span class="hkey">Control</span>, <span class="hkey">Option</span>, <span class="hkey">Command</span>, <span class="hkey">Menu</span>, <span class="hkey">Caps Lock</span>, <span class="hkey">Num Lock</span>, and <span class="hkey">Scroll Lock</span>. These states are
discussed under “<span class="xref std std-ref">Modifier Keys</span>” in the <span class="xref std std-ref">Keyboard Information</span>
appendix. They fairly closely match the key caps found on a Macintosh
keyboard, but only partially match those on a standard PC keyboard—which
generally has a set of <span class="hkey">Alt</span>(ernate) keys, rarely <span class="hkey">Option</span>
keys, and only sometimes <span class="hkey">Command</span> and <span class="hkey">Menu</span> keys. Because of
these differences, the mapping of keys to modifiers is the area of the key
map most open to the user’s personal judgement and taste, and consequently
to changes in the default configuration.</p>
<p>Since two keys, one on the left and one on the right, can be mapped to the
<span class="hkey">Shift</span>, <span class="hkey">Control</span>, <span class="hkey">Option</span>, and <span class="hkey">Command</span>
modifiers, the keyboard can have as many as twelve modifier keys. The
<span class="htype">key_map</span> structure has one field for each key:</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32caps_key</p></td>
<td><p>The key that functions as the <span class="hkey">Caps Lock</span> key; by default, this is
the key labeled “Caps Lock,” key 0x3b.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32scroll_key</p></td>
<td><p>The key that functions as the <span class="hkey">Scroll Lock</span> key; by default, this is
the key labeled “Scroll Lock,” key 0x0f.</p></td>
</tr>
<tr class="row-even"><td><p>uint32num_key</p></td>
<td><p>The key that functions as the <span class="hkey">Num Lock</span> key; by default, this is
the key labeled “Num Lock,” key 0x22.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32left_shift_key</p></td>
<td><p>A key that functions as a <span class="hkey">Shift</span> key; by default, this is the key
on the left labeled “Shift,” key 0x4b.</p></td>
</tr>
<tr class="row-even"><td><p>uint32right_shift_key</p></td>
<td><p>Another key that functions as a <span class="hkey">Shift</span> key; by default, this is the
key on the right labeled “Shift,” key 0x56.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32left_command_key</p></td>
<td><p>A key that functions as a <span class="hkey">Command</span> key; by default, this is key
0x5d, sometimes labeled “Alt.”</p></td>
</tr>
<tr class="row-even"><td><p>uint32right_command_key</p></td>
<td><p>Another key that functions as a <span class="hkey">Command</span> key; by default, this is
key 0x5f, sometimes labeled “Alt.”</p></td>
</tr>
<tr class="row-odd"><td><p>uint32left_control_key</p></td>
<td><p>A key that functions as a <span class="hkey">Control</span> key; by default, this is the key
labeled “Control” on the left, key 0x5c.</p></td>
</tr>
<tr class="row-even"><td><p>uint32right_control_key</p></td>
<td><p>Another key that functions as a <span class="hkey">Control</span> key; by default on
keyboards that have Option keys, this key is the key labeled “Control” on
the right, key 0x60. For keyboards that don’t have <span class="hkey">Option</span> keys,
this field is unmapped (its value is 0); key 0x60 is used as an
<span class="hkey">Option</span> key.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32left_option_key</p></td>
<td><p>A key that functions as an <span class="hkey">Option</span> key; by default, this is key
0x66, which has different labels on different keyboards—“Option,”
“Command,” or a Windows symbol. This key doesn’t exist on, and therefore
isn’t mapped for, a standard 101-key keyboard.</p></td>
</tr>
<tr class="row-even"><td><p>uint32right_option_key</p></td>
<td><p>A key that functions as an <span class="hkey">Option</span> key; by default, this is key
0x67, which has different labels on different keyboards—“Option,”
“Command,” or a Windows symbol. For keyboards without this key, the field
is mapped to the key labeled “Control” on the right, key 0x60.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32menu_key</p></td>
<td><p>A key that initiates keyboard navigation of the menu hierarchy; by
default, this is the key labeled with a menu symbol, key 0x68. This key
doesn’t exist on, and therefore isn’t mapped for, a standard 101-key
keyboard.</p></td>
</tr>
</tbody>
</table>
<p>Each field names the key that functions as that modifier. For example,
when the user holds down the key whose code is set in the
<span class="hparameter">right_option_key</span> field, the <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OPTION_KEY</span></code> and
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_OPTION_KEY</span></code> bits are turned on in the modifiers
mask that the <span class="xref std std-ref">modifiers()</span> function returns. When the user then
strikes a character key, the <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OPTION_KEY</span></code> state
influences the character that’s generated.</p>
<p>If a modifier field is set to a value that doesn’t correspond to an actual
key on the keyboard (including 0), that field is not mapped. No key fills
that particular modifier role.</p>
<p class="rubric">Keyboard locks</p>
<p>One field of the key map sets initial modifier states:</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32lock_settings</p></td>
<td><p>A mask that determines which keyboard locks are turned on when the machine
reboots or when the default key map is restored.</p></td>
</tr>
</tbody>
</table>
<p>The mask can be 0 or may contain any combination of these three constants:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CAPS_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SCROLL_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NUM_LOCK</span></code></p></li>
</ul>
<p>It’s 0 by default; there are no initial locks.</p>
<p>Altering the <span class="hparameter">lock_settings</span> field has no effect unless the
altered key map is made the default.</p>
<p class="rubric">Character Maps</p>
<p>The principal job of the key map is to assign character values to keys.
This is done in a series of nine tables:</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32control_map[128]</p></td>
<td><p>The characters that are produced when a <span class="hkey">Control</span> key is down but
both <span class="hkey">Command</span> keys are up.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32option_caps_shift_map[128]</p></td>
<td><p>The characters that are produced when <span class="hkey">Caps Lock</span> is on and both a
<span class="hkey">Shift</span> key and an <span class="hkey">Option</span> key are down.</p></td>
</tr>
<tr class="row-even"><td><p>uint32option_caps_map[128]</p></td>
<td><p>The characters that are produced when <span class="hkey">Caps Lock</span> is on and an
<span class="hkey">Option</span> key is down.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32option_shift_map[128]</p></td>
<td><p>The characters that are produced when both a <span class="hkey">Shift</span> key and an
<span class="hkey">Option</span> key are down.</p></td>
</tr>
<tr class="row-even"><td><p>uint32option_map[128]</p></td>
<td><p>The characters that are produced when an <span class="hkey">Option</span> key is down.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32caps_shift_map[128]</p></td>
<td><p>The characters that are produced when <span class="hkey">Caps Lock</span> is on and a
<span class="hkey">Shift</span> key is down.</p></td>
</tr>
<tr class="row-even"><td><p>uint32caps_map[128]</p></td>
<td><p>The characters that are produced when <span class="hkey">Caps Lock</span> is on.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32shift_map[128]</p></td>
<td><p>The characters that are produced when a <span class="hkey">Shift</span> key is down.</p></td>
</tr>
<tr class="row-even"><td><p>uint32normal_map[128]</p></td>
<td><p>The characters that are produced when none of the other tables apply.</p></td>
</tr>
</tbody>
</table>
<p>Each of these tables is an array of 128 offsets into another array, the
chars array of Unicode UTF-8 character encodings. get_key_map() provides a
pointer to the chars array as its second argument.</p>
<p>Key codes are used as indices into the character tables. The offset stored
at any particular index maps a character to that key. For example, the code
assigned to the <span class="hkey">M</span> key is 0x52; at index 0x52 in the
<span class="hparameter">option_caps_map</span> is an offset; at that offset in the chars array,
you’ll find the character that’s mapped to the <span class="hkey">M</span> key when an
<span class="hkey">Option</span> key is held down and <span class="hkey">Caps Lock</span> is on.</p>
<p>This indirection—an index to an offset to a character—is required because
characters are encoded as Unicode UTF-8 strings. Character values of 127 or
less (7-bit ASCII) are just a single byte, but UTF-8 takes two, three, or
(rarely) four bytes to encode values over 127.</p>
<p>The chars array represents each character as a Pascal string—the first
byte in the string tells how many other bytes the string contains. For
example, the string for the trademark symbol (™) looks like this:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>x03xE2x84xA2
</pre></div>
</div>
<p>The first byte (x03) indicates that Unicode UTF-8 takes 3 bytes to
represent the trademark symbol, and those bytes follow (xE2x84xA2). Pascal
strings are not null-terminated.</p>
<p>Here’s an example showing you how to decode the character tables. This
sample prints out a simple chart of the <span class="hparameter">normal_map</span>,
<span class="hparameter">shift_map</span>, <span class="hparameter">option_map</span>, and <span class="hparameter">option_shift_map</span>
characters:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;interface/InterfaceDefs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_key</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chars</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="k">switch</span><span class="p">(</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Not mapped</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;N/A&quot;</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 1-byte UTF-8/ASCII character</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="c1">// 2-, 3-, or 4-byte UTF-8 character</span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="kt">char</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">strncpy</span><span class="p">(</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">chars</span><span class="p">[</span><span class="n">offset</span><span class="p">]),</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">printf</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Get the current key map.</span>
<span class="w">   </span><span class="n">key_map</span><span class="w"> </span><span class="o">*</span><span class="n">keys</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">chars</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">get_key_map</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keys</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chars</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Print a chart of the normal, shift, option, and option+shift</span>
<span class="w">   </span><span class="c1">// keys.</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Key #tNormaltShifttOptiontOption+Shiftn&quot;</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="w"> </span><span class="s">&quot; %3dt&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">print_key</span><span class="p">(</span><span class="w"> </span><span class="n">chars</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="o">-&gt;</span><span class="n">normal_map</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">print_key</span><span class="p">(</span><span class="w"> </span><span class="n">chars</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="o">-&gt;</span><span class="n">shift_map</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">print_key</span><span class="p">(</span><span class="w"> </span><span class="n">chars</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="o">-&gt;</span><span class="n">option_map</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">print_key</span><span class="p">(</span><span class="w"> </span><span class="n">chars</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="o">-&gt;</span><span class="n">option_shift_map</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Free our copy of the key map.</span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="w"> </span><span class="n">chars</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The character map tables are ordered. Values from the first applicable
table are used, even if another table might also seem to apply. For
example, if <span class="hkey">Caps Lock</span> is on and a <span class="hkey">Control</span> key is down (and
both <span class="hkey">Command</span> keys are up), the <span class="hparameter">control_map</span> array is used,
not <span class="hparameter">caps_map</span>. If a <span class="hkey">Shift</span> key is down and <span class="hkey">Caps Lock</span> is on, the <span class="hparameter">caps_shift_map</span> is used, not <span class="hparameter">shift_map</span>
or <span class="hparameter">caps_map</span>.</p>
<p>Notice that the last eight tables (all except <span class="hparameter">control_map</span>) are
paired, with a table that names the <span class="hkey">Shift</span> key
(<span class="hparameter">…_shift_map</span>) preceding an equivalent table without
<span class="hkey">Shift</span>:</p>
<ul class="simple">
<li><p><span class="hparameter">option_caps_shift_map</span> is paired with <span class="hparameter">option_caps_map</span>,</p></li>
<li><p><span class="hparameter">option_shift_map</span> with <span class="hparameter">option_map</span>,</p></li>
<li><p><span class="hparameter">caps_shift_map</span> with <span class="hparameter">caps_map</span>, and</p></li>
<li><p><span class="hparameter">shift_map</span> with <span class="hparameter">normal_map</span>.</p></li>
</ul>
<p>These pairings are important for a special rule that applies to keys on
the numerical keypad when <span class="hkey">Num Lock</span> is on:</p>
<ul class="simple">
<li><p>If the <span class="hkey">Shift</span> key is down, the non-<span class="hkey">Shift</span> table is used.</p></li>
<li><p>However, if the <span class="hkey">Shift</span> key is not down, the <span class="hkey">Shift</span> table is
used.</p></li>
</ul>
<p>In other words, <span class="hkey">Num Lock</span> inverts the <span class="hkey">Shift</span> and
non-<span class="hkey">Shift</span> tables for keys on the numerical keypad.</p>
<p>Not every key needs to be mapped to a character. If the chars array has a
0-length string for a key, the key is not mapped to a character (given the
particular modifier states the table represents). Generally, modifier keys
are not mapped to characters, but all other keys are, at least for some
tables. Key-down events are not generated for unmapped keys.</p>
<p class="rubric">Dead keys</p>
<p>Next are the tables that map combinations of keys to single characters.
The first key in the combination is “dead”—it doesn’t produce a key-down
event until the user strikes another character key. When the user hits the
second key, one of two things will happen: If the second key is one that
can be used in combination with the dead key, a single key-down event
reports the combination character. If the second key doesn’t combine with
the dead key, two key-down events occur, one reporting the dead-key
character and one reporting the second character.</p>
<p>There are five dead-key tables:</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int32acute_dead_key[32]</p></td>
<td><p>The table for combining an acute accent (´) with other characters.</p></td>
</tr>
<tr class="row-odd"><td><p>int32grave_dead_key[32]</p></td>
<td><p>The table for combining a grave accent (`) with other characters.</p></td>
</tr>
<tr class="row-even"><td><p>int32circumflex_dead_key[32]</p></td>
<td><p>The table for combining a circumflex (^) with other characters.</p></td>
</tr>
<tr class="row-odd"><td><p>int32dieresis_dead_key[32]</p></td>
<td><p>The table for combining a dieresis (¨) with other characters.</p></td>
</tr>
<tr class="row-even"><td><p>int32tilde_dead_key[32]</p></td>
<td><p>The table for combining a tilde (~) with other characters</p></td>
</tr>
</tbody>
</table>
<p>The tables are named after diacritical marks that can be placed on more
than one character. However, the name is just a mnemonic; it means nothing.
The contents of the table determine what the dead key is and how it
combines with other characters. It would be possible, for example, to remap
the <span class="hparameter">tilde_dead_key</span> table so that it had nothing to do with a
tilde.</p>
<p>Each table consists of a series of up to 16 offset pairs—where, as in the
case of the character maps, each offset picks a character from the chars
character array. The first character in the pair is the one that must be
typed immediately after the dead key. The second character is the resulting
character, the character that’s produced by the combination of the dead key
plus the first character in the pair. For example, if the first character
is ‘o’, the second might be ‘^’—meaning that the combination of a dead key
plus the character ‘o’ produces a circumflexed ‘ô’.</p>
<p>The character pairs for the default <span class="hparameter">grave_dead_key</span> array look
something like this:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>&#39; &#39;, &#39;&#39;&#39;,
&#39;A&#39;, &#39;À&#39;,
&#39;E&#39;, &#39;È&#39;,
&#39;I&#39;, &#39;Ì&#39;,
&#39;O&#39;, &#39;Ò&#39;,
&#39;U&#39;, &#39;Ù&#39;,
&#39;a&#39;, &#39;à&#39;,
&#39;e&#39;, &#39;è&#39;,
&#39;i&#39;, &#39;ì&#39;&#39;o&#39;, &#39;ò&#39;,
&#39;u&#39;, &#39;ù&#39;,
. . .
</pre></div>
</div>
<p>By convention, the first offset in each array is to the
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SPACE</span></code> character and the second is to the dead-key
character itself. This pair does double duty: It states that the dead key
plus a space yields the dead-key character, and it also names the dead key.
The system understands what the dead key is from the second offset in the
array.</p>
<p class="rubric">Character Tables For Dead Keys</p>
<p>As mentioned above, for a key to be dead, it must be mapped to the
character picked by the second offset in a dead-key array. However, it’s
not typical for every key that’s mapped to the character to be dead.
Usually, there’s a requirement that the user must hold down certain
modifier keys (often the <span class="hkey">Option</span> key). In other words, a key is dead
only if selected character-map tables map it to the requisite character.</p>
<p>Five additional fields of the <span class="htype">key_map</span> structure specify what
those character-map tables are—which modifiers are required for each of the
dead keys:</p>
<table class="colwidths-auto docutils align-left">
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32acute_tables</p></td>
<td><p>The character tables that cause a key to be dead when they map it to the
second character in the acute_dead_key array.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32grave_tables</p></td>
<td><p>The character tables that cause a key to be dead when they map it to the
second character in the grave_dead_key array.</p></td>
</tr>
<tr class="row-even"><td><p>uint32circumflex_tables</p></td>
<td><p>The character tables that cause a key to be dead when they map it to the
second character in the circumflex_dead_key array.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32dieresis_tables</p></td>
<td><p>The character tables that cause a key to be dead when they map it to the
second character in the dieresis_dead_key array.</p></td>
</tr>
<tr class="row-even"><td><p>uint32tilde_tables</p></td>
<td><p>The character tables that cause a key to be dead when they map it to the
second character in the tilde_dead_key array.</p></td>
</tr>
</tbody>
</table>
<p>Each of these fields contains a mask formed from the following constants:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CONTROL_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CAPS_SHIFT_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OPTION_CAPS_SHIFT_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CAPS_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OPTION_CAPS_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SHIFT_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OPTION_SHIFT_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NORMAL_TABLE</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OPTION_TABLE</span></code></p></li>
</ul>
<p>The mask designates the character-map tables that permit a key to be dead.
For example, if the mask for the <span class="hparameter">grave_tables</span> field is,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">B_OPTION_TABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">B_OPTION_CAPS_SHIFT_TABLE</span><span class="w"></span>
</pre></div>
</div>
<p>a key would be dead whenever either of those tables mapped the key to the
character of the second offset in the <span class="hparameter">grave_dead_key</span> array (‘Q’
in the example above). A key mapped to the same character by another table
would not be dead.</p>
<p>See also: <span class="xref std std-ref">get_key_info()</span>, <span class="xref std std-ref">modifiers()</span>, the Keyboard
Information appendix, <span class="xref std std-ref">set_modifier_key()</span></p>
<section id="_CPPv415get_keyboard_idP6uint16">
</section>
<h3>
get_keyboard_id()</h3><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_keyboard_id</span><span class="sig-paren">(</span><span class="n">uint16</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">id</span><span class="sig-paren">)</span></pre><p>Declared in:  interface/InterfaceDefs.h</p>
<p>Obtains the keyboard identifier from the Application Server and device
driver and writes it into the variable referred to by <span class="hparameter">id</span>. This
number reveals what kind of keyboard is currently attached to the computer.</p>
<p>The identifier for the standard 101-key PC keyboard—and for keyboards with
a similar set of keys—is 0x83ab.</p>
<p>If unsuccessful for any reason, get_keyboard_id() returns
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_ERROR</span></code>. If successful, it returns
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code>.</p>
<section id="_CPPv49modifiersv">
</section>
<h3>
modifiers()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="n">uint32</span><span class="w"> </span><span class="n">modifiers</span><span class="sig-paren">(</span><span class="sig-paren">)</span></pre><p>Declared in: interface/InterfaceDefs.h</p>
<p>Returns a mask that has a bit set for each modifier key the user is
holding down and for each keyboard lock that’s set. The mask can be tested
against these constants:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SHIFT_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_COMMAND_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CAPS_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CONTROL_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_MENU_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SCROLL_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OPTION_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NUM_LOCK</span></code></p></li>
</ul>
<p>No bits are set (the mask is 0) if no locks are on and none of the
modifiers keys are down.</p>
<p>If it’s important to know which physical key the user is holding down, the
one on the right or the one on the left, the mask can be further tested
against these constants:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_SHIFT_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_SHIFT_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_CONTROL_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_CONTROL_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_OPTION_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_OPTION_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_COMMAND_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_COMMAND_KEY</span></code></p></li>
</ul>
<p>By default, the keys closest to the space bar function as <span class="hkey">Command</span>
keys, no matter what their labels on particular keyboards. If a keyboard
doesn’t have <span class="hkey">Option</span> keys (for example, a standard 101-key
keyboard), the key on the right labeled &amp; quot;Control” functions as the
right <span class="hkey">Option</span> key, and only the left “Control” key is available to
function as a <span class="hkey">Control</span> modifier. However, users can change this
configuration with the /bin/keymap application.</p>
<section id="_CPPv419set_key_repeat_rate5int32">
</section>
<section id="_CPPv419get_key_repeat_rateP5int32">
</section>
<section id="_CPPv420set_key_repeat_delay9bigtime_t">
</section>
<section id="_CPPv420get_key_repeat_delayP9bigtime_t">
</section>
<h3>
set_key_repeat_rate(), get_key_repeat_rate(), set_key_repeat_delay(), get_key_repeat_delay()</h3><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">set_key_repeat_rate</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="n sig-param">rate</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_key_repeat_rate</span><span class="sig-paren">(</span><span class="n">int32</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">rate</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">set_key_repeat_delay</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="n sig-param">delay</span><span class="sig-paren">)</span></pre><pre style="background: #f3f3f3; line-height: 2em"><a class="reference internal" href="../storage/the-node-monitor.html#_CPPv48status_t10BMessenger" title="status_t"><span class="n">status_t</span></a><span class="w"> </span><span class="n">get_key_repeat_delay</span><span class="sig-paren">(</span><span class="n">bigtime_t</span><span class="w"> </span><span class="p">*</span><span class="n sig-param">delay</span><span class="sig-paren">)</span></pre><p>Declared in: interface/InterfaceDefs.h</p>
<p>These functions set and report the timing of repeating keys. When the user
presses a character key on the keyboard, it produces an immediate
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_KEY_DOWN</span></code> message. If the user continues to hold the key
down, it will, after an initial delay, continue to produce messages at
regularly spaced intervals—until the user releases the key or presses
another key. The delay and the spacing between messages are both
preferences the user can set with the Keyboard application.</p>
<p>set_key_repeat_rate() sets the number of messages repeating keys produce
per second. For a standard PC keyboard, the rate can be as low as 2 and as
high as 30; get_key_repeat_rate() writes the current setting into the
integer that rate refers to.</p>
<p>set_key_repeat_delay() sets the length of the initial delay before the key
begins repeating. Acceptable values are 250,000, 500,000, 750,000 and
1,000,000 microseconds (.25, .5, .75, and 1.0 second);
get_key_repeat_delay() writes the current setting into the variable that
delay points to.</p>
<p>All four functions return <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_OK</span></code> if they successfully
communicate with the Application Server, and <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_ERROR</span></code> if
not. It’s possible for the set…() functions to communicate with the server
but not succeed in setting the rate or delay (for example, if the delay
isn’t one of the listed four values).</p>
<section id="_CPPv418set_keyboard_locks6uint32">
</section>
<h3>
set_keyboard_locks()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">void</span><span class="w"> </span><span class="n">set_keyboard_locks</span><span class="sig-paren">(</span><span class="n">uint32</span><span class="w"> </span><span class="n sig-param">modifiers</span><span class="sig-paren">)</span></pre><p>Declared in: interface/InterfaceDefs.h</p>
<p>Turns the keyboard locks—<span class="hkey">Caps Lock</span>, <span class="hkey">Num Lock</span>, and
<span class="hkey">Scroll Lock</span>—on and off. The keyboard locks that are listed in the
modifiers mask passed as an argument are turned on; those not listed are
turned off. The mask can be 0 (to turn off all locks) or it can contain any
combination of the following constants:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CAPS_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NUM_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SCROLL_LOCK</span></code></p></li>
</ul>
<p>See also: <span class="xref std std-ref">get_key_map()</span>, <span class="xref std std-ref">modifiers()</span></p>
<section id="_CPPv416set_modifier_key6uint326uint32">
</section>
<h3>
set_modifier_key()</h3><pre style="background: #f3f3f3; line-height: 2em"><span class="kt">void</span><span class="w"> </span><span class="n">set_modifier_key</span><span class="sig-paren">(</span><span class="n">uint32</span><span class="w"> </span><span class="n sig-param">modifier</span>, <span class="n">uint32</span><span class="w"> </span><span class="n sig-param">key</span><span class="sig-paren">)</span></pre><p>Declared in: interface/InterfaceDefs.h</p>
<p>Maps a modifier role to a particular key on the keyboard, where key is a
key identifier and modifier is one of the these constants:</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_CAPS_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_SHIFT_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_SHIFT_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_NUM_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_CONTROL_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_CONTROL_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_SCROLL_LOCK</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_OPTION_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_OPTION_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_MENU_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_LEFT_COMMAND_KEY</span></code></p></li>
<li><p><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_RIGHT_COMMAND_KEY</span></code></p></li>
</ul>
<p>The key in question serves as the named modifier key, unmapping any key
that previously played that role. The change remains in effect until the
default key map is restored. In general, the user’s preferences for
modifier keys—expressed in the Keymap application—should be respected.</p>
<p>Modifier keys can also be mapped by calling <span class="xref std std-ref">get_key_map()</span> and
altering the <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">key_map</span></code> structure directly. This
function is merely a convenient alternative for accomplishing the same
thing. (It’s currently not possible to alter the key map;
<span class="xref std std-ref">get_key_map()</span> looks at a copy.)</p>
<section id="instantiate-input-device">
<h3>instantiate_input_device()<a class="headerlink" href="#instantiate-input-device" title="Permalink to this heading">¶</a></h3>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>TODO: This function does not appear in the BeBook</p>
</div>
</section>
<section id="instantiate-input-filter">
<h3>instantiate_input_filter()<a class="headerlink" href="#instantiate-input-filter" title="Permalink to this heading">¶</a></h3>
<div class="note admonition">
<p class="admonition-title">Note</p>
<p>TODO: This function does not appear in the BeBook</p>
</div>
</section>
</section>
</section>


        <div class="clearer"></div>
      </div>
          </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../game/window-screen.html">BWindowScreen</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="input-device.html">BInputDevice</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Haiku, Inc..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>