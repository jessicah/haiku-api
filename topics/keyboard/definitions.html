
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Definitions &#8212; The Haiku Book  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/code.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Introduction" href="introduction.html" />
    <link rel="prev" title="Character Constants" href="character-constants.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>API Documentation</span></a></h1>
        <h2 class="heading"><span>Definitions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="character-constants.html">Character Constants</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="introduction.html">Introduction</a>&#160;&#160;»
        </p>

      </div>
        
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Definitions</a><ul>
<li><a class="reference internal" href="#key-codes">Key Codes</a></li>
<li><a class="reference internal" href="#the-keymap">The Keymap</a></li>
<li><a class="reference internal" href="#character-keys">Character Keys</a></li>
<li><a class="reference internal" href="#modifier-keys">Modifier Keys</a></li>
<li><a class="reference internal" href="#the-scroll-lock-key">The Scroll Lock Key</a></li>
<li><a class="reference internal" href="#repeating-keys">Repeating Keys</a></li>
<li><a class="reference internal" href="#dead-keys">Dead Keys</a></li>
</ul>
</li>
</ul>

  </div>

        </div>
      </div>
          <div class="bodywrapper">
      <div class="content" role="main">
        
  <section id="definitions">
<h1 id="CPPv411Definitions">Definitions<a class="headerlink" href="#definitions" title="Permalink to this heading">¶</a></h1>
<p>This section lists and describes the keyboard terms and concepts that you
should be familiar with.</p>
<section id="key-codes">
<h2>Key Codes<a class="headerlink" href="#key-codes" title="Permalink to this heading">¶</a></h2>
<p>Keyboards come in a variety of styles and sizes, with different numbers of
keys on them, sometimes in different positions. Some special keys or
symbols even appear more than once on the same keyboard—for example, most
keyboards have two <span class="hkey">Enter</span> keys (sometimes one or both of them is
called <span class="hkey">Return</span>). Most keyboards have two <span class="hkey">Shift</span> keys, and
many have two keys that can generate the “=” character—one of them on the
numeric keypad.</p>
<p>Each of these keys is unique as far as the hardware is concerned, even if
they usually generate the same result as far as the user is concerned.
Because of this, each key has a unique number, called a key code. This is a
numeric byte value between 0x01 and 0x7F. They’re not the same as the ASCII
or <span class="xref std std-ref">Unicode™</span> values for the characters generated by the keys—which
makes sense, since not every key generates a character.</p>
<p>For example, the left <span class="hkey">Shift</span> key has the key code value of 0x4B,
and the right <span class="hkey">Shift</span> key has the key code of 0x56. Neither of these
generates a <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_KEY_UP</span></code> event (although they do generate a
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_MODIFIERS_CHANGED</span></code> event). The additional implication
here is clear: software can actually tell the difference between these two
keys—and any other keys that generate the same Unicode value—if they need
to do so.</p>
<p>It’s also important to note that key codes don’t differentiate between
shifted and unshifted keys. Pressing <span class="hkey">A</span> generates the key code 0x27
whether the <span class="hkey">Caps Lock</span> or <span class="hkey">Shift</span> key is down or not.</p>
</section>
<section id="the-keymap">
<h2>The Keymap<a class="headerlink" href="#the-keymap" title="Permalink to this heading">¶</a></h2>
<p>Most software written these days expects keys to be received in either
ASCII or Unicode format (or, in the case of BeOS, in UTF-8 format, which is
a form of Unicode in which the ASCII codes are contained). So obviously
receiving a value of 0x27 for the <span class="hkey">A</span> key isn’t going to help a
program that expects to receive 0x41, the UTF-8 value for the character
“A”.</p>
<p>So clearly the key codes the input server add-on obtains from the keyboard
device need to be translated into UTF-8. This is done by using a keymap.
This is a table that can be used to look up a key code and determine, based
on which modifier keys are currently engaged, the UTF-8 bytes that should
be generated. It also defines which keys are treated as modifier keys.</p>
<p>BeOS maintains a keymap for use by all applications. Applications that
want to look up key codes in the keymap can call <span class="xref std std-ref">get_key_map()</span> to
get a copy of it. The Keymap preference panel can be used to configure the
system keymap.</p>
</section>
<section id="character-keys">
<h2>Character Keys<a class="headerlink" href="#character-keys" title="Permalink to this heading">¶</a></h2>
<p>A character key is a key that’s mapped to a particular UTF-8 byte or byte
sequence. For example, in the standard American keymap, the key labeled
<span class="hkey">A</span> is mapped to the letter “a” when pressed with no modifier keys
down, “A” when the <span class="hkey">Caps Lock</span> or a <span class="hkey">Shift</span> key is down, and
<span class="hkey">control</span>+<span class="hkey">A</span> (UTF-8 code 0x01) when the <span class="hkey">Control</span> key is
down. Mapped character keys generate <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_KEY_DOWN</span></code> and
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_KEY_UP</span></code> messages when they’re pressed and released.</p>
<p>Keys that aren’t mapped to characters generate
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_UNMAPPED_KEY_DOWN</span></code> and
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_UNMAPPED_KEY_UP</span></code> messages.</p>
</section>
<section id="modifier-keys">
<h2>Modifier Keys<a class="headerlink" href="#modifier-keys" title="Permalink to this heading">¶</a></h2>
<p>Modifier keys set states that affect the way character keys are
interpreted. Some modifier keys, such as <span class="hkey">Caps Lock</span>, toggle in and
out of a locked-on or locked-off position each time they’re pressed.
Others, like Shift, set the state only as long as they’re held down.</p>
<p>The keymap contains lists of how to interpret each key depending on which
modifier keys are currently engaged.</p>
</section>
<section id="the-scroll-lock-key">
<h2>The Scroll Lock Key<a class="headerlink" href="#the-scroll-lock-key" title="Permalink to this heading">¶</a></h2>
<p>The <span class="hkey">Scroll Lock</span> key is unique. In the standard keyboard Input
Server add-on, it both generates a character and sets a modifier state.</p>
</section>
<section id="repeating-keys">
<h2>Repeating Keys<a class="headerlink" href="#repeating-keys" title="Permalink to this heading">¶</a></h2>
<p>When a key is pressed and held down, it produces a continuous series of
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_KEY_DOWN</span></code> or <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_UNMAPPED_KEY_DOWN</span></code>
messages, as long as the key is still held down and doesn’t press another
key. After the first message, there’s a slight delay before the key begins
repeating. This delay can be determined by calling
<span class="xref std std-ref">get_key_repeat_delay()</span> and can be changed by calling
<span class="xref std std-ref">set_key_repeat_delay()</span> (although you should leave the user’s
preference for this alone).</p>
<p>After the key begins to repeat, the <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_KEY_DOWN</span></code> or
<code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">B_UNMAPPED_KEY_DOWN</span></code> messages are sent at a fixed rate;
this rate can be determined by calling <span class="xref std std-ref">get_key_repeat_rate()</span>.</p>
<p>All keys repeat except <span class="hkey">Pause</span>, <span class="hkey">Break</span>, <span class="hkey">Caps Lock</span>,
<span class="hkey">Num Lock</span>, and <span class="hkey">Scroll Lock</span>.</p>
</section>
<section id="dead-keys">
<h2>Dead Keys<a class="headerlink" href="#dead-keys" title="Permalink to this heading">¶</a></h2>
<p>Dead keys don’t generate characters until the user strikes another key. If
the key the user presses after the dead key is in a particular set, the two
keys together produce one key-down event (and, usually, one character). If
the second keystroke isn’t in that set, two key-down events are generated.</p>
<p>Dead keys are only dead when certain prescribed modifiers (by default,
just the Option key) are held down. They’re most appropriate when the
character to be generated can be thought of as being composed of two
distinguishable parts—such as “a” and “e” combining into “æ”.</p>
<p>The system permits up to five dead keys. By default, they’re reserved for
combining diacritical marks with other characters. The diacritical marks
are the acute (´) and grave (`) accents, dieresis (¨), circumflex (^), and
tilde (~).</p>
</section>
</section>


        <div class="clearer"></div>
      </div>
          </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="character-constants.html">Character Constants</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="introduction.html">Introduction</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Haiku, Inc..
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>